[
  {
    "t1": {
      "identity": 1682,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "cypher",
        "link": "https://stackoverflow.com/questions/tagged/cypher"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1682"
    },
    "t2": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "questions": [
      {
        "identity": 391,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have tried the following query, wherein I am trying to get the person who has contact and if that contact directed a movie then movie name. in this, I am trying to avoid null for movie names.

but below query is not working, **I have even tried IS NOT NULL.** and m.title &lt;&gt; NULL
 
    MATCH (a:Person)-[:HAS_CONTACT]-&gt;(b)
    OPTIONAL MATCH (b)-[:DIRECTED]-&gt;(m:Movie)
    WHERE m &lt;&gt; NULL
    RETURN a.name, b.name,m.title
    LIMIT 1


RESULT:

    	a.name	b.name	m.title
    &quot;Keanu Reeves&quot;	&quot;Rita Wilson&quot;	null",
          "link": "https://stackoverflow.com/q/62871443",
          "creation_date": 1594626761,
          "answer_count": 2,
          "title": "even after null check why I am getting null value in neo4j?",
          "uuid": 62871443,
          "view_count": 14
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:391"
      },
      {
        "identity": 165,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 64720783,
          "body_markdown": "I have developed a query which, by trial and error, appears to find all of the duplicated relationships in a Neo4j DB. I want delete all but one of these relationships but I&#39;m concerned that I have not thought of problematic cases that could result in data deletion.

So, does this query delete all but one of a duplicated relationship?

    MATCH (a)--&gt;(b)&lt;--(a)  # identify where the duplication is present
    WITH DISTINCT a, b
    MATCH (a)-[r]-&gt;(b)  # get all duplicated paths themselves
    WITH a, b, collect(r)[1..] as rs  # remove the first instance from the list
    UNWIND rs as r
    DELETE r

If I replace the `UNWIND rs as r; DELETE r` with `WITH a, b, count(rs) as cnt RETURN cnt` it seems to return the unnecessary relationships.

I&#39;m still relucant to put this somewhere to be used by others, though....

Thanks",
          "link": "https://stackoverflow.com/q/64720139",
          "creation_date": 1604688667,
          "answer_count": 1,
          "title": "Deleting duplicate relationships in neo4j - is this correct?",
          "uuid": 64720139,
          "view_count": 77
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:165"
      },
      {
        "identity": 297,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "
I want to view the schema of my graph (Neo4j v4.1.1) that has a large number of labels and relationship types. I am working on a query to specify the labels of interest so that the result is less crowded.

    CALL db.schema.visualization() YIELD nodes, relationships 
    UNWIND nodes AS n 
    UNWIND relationships AS r 
    RETURN n, r

But I can&#39;t access any of the properties of the nodes and relationships returned by the procedure call. I have tried:
- `n.labels`
- `n[&quot;labels&quot;]`
- `keys(n)`
- `properties(n)`
- `labels(n)`

All of the above return either empty or null values. How can I access these properties so that I can filter the schema results by label?
",
          "link": "https://stackoverflow.com/q/63714375",
          "creation_date": 1599086168,
          "answer_count": 1,
          "title": "Cannot access property of nodes returned from schema procedure call",
          "uuid": 63714375,
          "view_count": 21
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:297"
      },
      {
        "identity": 4836,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am importing csv file from import directory by cypher and I would like to create nodes with labels from csv file. Which would look something like this

    LOAD CSV WITH HEADERS FROM &quot;file:///B.csv&quot; AS csv
    CREATE (c:csv.Type {name:csv.Name})
    return c 
I know that this is wrong, but hope you can show me the right way to do it. I couldn&#39;t find any answer in both neo4j community and in stackoverflow. 
",
          "link": "https://stackoverflow.com/q/68529849",
          "creation_date": 1627302541,
          "title": "Get node label name from csv file",
          "answer_count": 1,
          "uuid": 68529849,
          "view_count": 13
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4836"
      },
      {
        "identity": 213,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 64345767,
          "body_markdown": "I am trying to create a dynamic query which will get me results from &quot;today&quot; (when submitted) and so many days backwards.

Lets say for the sake of the example that I want the last 14 days of data, from today.

The field `first_submitted` is recorded by use of `timestamp()`

I have tried the following code;

    match(u:data) WHERE u.first_submitted &gt; timestamp()}-duration(&#39;P14D&#39;) AND u.first_submitted &lt; timestamp() RETURN u.first_submitted LIMIT 10

However I receive the error

    Neo.ClientError.Statement.TypeError: Cannot subtract `Duration` from `Long`


I tried a few different ways of coding this but am turning up very confused with the syntax and Neo4J&#39;s documentation surrounding this.

Alternatively, if you can think of a better way to do this that isn&#39;t resource too heavy please let me know.

Thanks in advance!

P.S. I&#39;m not sure what the &quot;data.apoch&quot; stuff I keep seeing is exactly but when I try to run any of these commands I receive errors so if I can avoid the need of this library please.",
          "link": "https://stackoverflow.com/q/64343604",
          "creation_date": 1602625551,
          "answer_count": 1,
          "title": "Neo4J Cypher - subtract duration from timestamp",
          "uuid": 64343604,
          "view_count": 229
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:213"
      }
    ]
  },
  {
    "t1": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "t2": {
      "identity": 1684,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j-apoc",
        "link": "https://stackoverflow.com/questions/tagged/neo4j-apoc"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1684"
    },
    "questions": [
      {
        "identity": 379,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have the following two triggers named &#39;loadEnrollments&#39; and &#39;loadDeenrollments&#39;.

    CALL apoc.trigger.add(&#39;loadEnrollments&#39;,
    &quot;UNWIND apoc.trigger.nodesByLabel($assignedLabels, &#39;Enrollment&#39;) AS node
     MERGE (p1:SPerson { name: node.name, cell: node.cell, created_at: node.created_at})
     WITH p1, node
     MATCH (n:SPerson)
     WITH node, COUNT(n) as size
     CALL apoc.do.when(
     size&gt;3,
     &#39;
     MATCH(p1:SPerson),(c:Course)
     WHERE p1.name=node.name AND c.name=\&quot;Paradigm Shifting 101\&quot;
     CREATE (p1)-[:Waitlist]-&gt;(c)
	 SET p1.status=2
     WITH node
     RETURN NULL&#39;,
     &#39;
     MATCH(p1:SPerson),(c:Course)
     WHERE p1.name=node.name AND c.name=\&quot;Paradigm Shifting 101\&quot;
     CREATE (p1)-[:Enrolled]-&gt;(c)
	 SET p1.status=1
     WITH node
     RETURN NULL&#39;, {node:node}) YIELD value
     DETACH DELETE node&quot;,

     { phase: &#39;after&#39; })



    CALL apoc.trigger.add(&#39;loadDeenrollments&#39;,
    &quot;
    UNWIND apoc.trigger.nodesByLabel($assignedLabels, &#39;Deenrollment&#39;) AS node
     MATCH (p1:SPerson {name: node.name, cell: node.cell})
     MATCH (c:Course {name: &#39;Paradigm Shifting 101&#39;})
     CREATE (p1)-[:Deenrolled]-&gt;(c)
	   SET p1.status=3
     WITH p1, node,c
     MATCH (p1:SPerson {name: node.name, cell: node.cell})-[r:Enrolled]-&gt;(c)
     DELETE r
     DETACH DELETE node
     WITH p1,c
     MATCH (p1)-[r:Enrolled]-&gt;(c)
     WITH COUNT(r) as k
     CALL apoc.do.when(
     k&lt;3,     &#39;
      MATCH (p1:SPerson)-[:Waitlist]-&gt;(c:Course)
      WITH min(p1.created_at) AS min
      MATCH (p1:SPerson),(c:Course)
      WHERE p1.created_at = min
      CREATE (p1)-[:Random]-&gt;(c)
      RETURN p1,c&#39;,
     &#39;
     MATCH (n:SPerson) RETURN n
     &#39;,{k:k}
     ) YIELD value
     RETURN NULL&quot;,

     { phase: &#39;after&#39; })


When I load both of them and create a &#39;Enrollment&#39; nodes by the following commands. The &#39;loadenrollment&#39; trigger works as desired and create SPerson nodes for cat1,cat2 and cat3 and creates an &#39;enrolled&#39; relationship with the &#39;course&#39; node.


    CREATE (:Enrollment { name: &quot;cat1&quot;, cell: &quot;123&quot;, created_at: TIMESTAMP()});
    CREATE (:Enrollment { name: &quot;cat2&quot;, cell: &quot;123&quot;, created_at: TIMESTAMP()});
    CREATE (:Enrollment { name: &quot;cat3&quot;, cell: &quot;123&quot;, created_at: TIMESTAMP()});

The Problem occurs when I create the 4th node 

    CREATE (:Enrollment { name: &quot;cat4&quot;, cell: &quot;123&quot;, created_at: TIMESTAMP()});
Ideally, it should create a SPerson node for cat4 and add a &#39;waitlist&#39; relationship with the &#39;course&#39; node.
But for some reason when I create that node it adds the &#39;waitlist&#39; relationship but also adds the &#39;Random&#39; relationship that I defined in the second trigger(&#39;loadDeenrollments&#39;). This should never happen as this trigger would only trigger when I create a &#39;Deenrollment&#39; node but for some reason it is executing that trigger.

Also, I tried adding just the &#39;loadEnrollments&#39; trigger and it works as desired(obviously, as there is no &#39;loadDeenrollments&#39; trigger) i.e. creating the four &#39;SPerson&#39; nodes and with three nodes having &#39;enrolled&#39; relationship and one having &#39;waitlist&#39; relationship.

I don&#39;t know whats&#39;s wrong. Any help is appreciated!",
          "link": "https://stackoverflow.com/q/62975957",
          "creation_date": 1595129708,
          "answer_count": 0,
          "title": "Neo4j- APOC trigger fires without any reason",
          "uuid": 62975957,
          "view_count": 71
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:379"
      },
      {
        "identity": 4686,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 69106124,
          "body_markdown": "I have a database where sentences are related to each other. I have to perform a big update on the whole database, thus I&#39;m trying to parallelize the update.

The relevant cypher query looks like this:
```
match (s:Sentence)-[r:RELATED]-(t:Sentence)
return s as sentence, collect(t.embedding) as neighbours_embeddings
```
`embedding` is a list of numbers.

This returns a result like this:
```
---------------------------------------
| sentence   |  neighbours_embeddings |
---------------------------------------
| sentence1  | [[1, 2, 3], [4, 5, 6]] | 
---------------------------------------
| sentence2  | [[2, 3, 5]]            |
---------------------------------------
```
Now I wanna perform some operations on the neighbours_embeddings and set a property in the corresponding Sentence node.

I&#39;ve looked at different parallelization techniques in Neo4j and as far as I understood, all of them need a list as input. But my input would be a tuple like (sentence, neighbours_embeddings). How do I achieve this?

Full query for interested folks:
```
match (s:Sentence)-[r:RELATED]-(t:Sentence)
with s as sentence, collect(t.embedding) as neighbours
with sentence, [
    w in reduce(s=[], neighbour IN neighbours | 
    case when size(s) = 0 then
    neighbour else [
        i in range(0, size(s)-1) |
        s[i] + neighbour[i]] end) |
        w / tofloat(size(neighbours))
    ] as average
 
 with sentence, [
     i in range(0, size(sentence.embedding)-1) |
     (0.8 * sentence.embedding[i]) + (0.2 *average[i])
 ] as unnormalized
 
 with sentence, unnormalized, sqrt(reduce(sum = 0.0, element in unnormalized | sum + element^2)) as divideby
 set sentence.normalized = [
     i in range(0, size(unnormalized)-1) | (unnormalized[i] / divideby)
 ]

```",
          "link": "https://stackoverflow.com/q/69016244",
          "creation_date": 1630508400,
          "answer_count": 1,
          "title": "Neo4j: Cypher query to parallelize a row of the result from a previous query",
          "uuid": 69016244,
          "view_count": 16
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4686"
      },
      {
        "identity": 447,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 62455687,
          "body_markdown": "The Problem to solve is:

    List: [x1, y1, z1], [x2, y2, z2] ...[xn, yn, zn]

Output expected: 

    [(x1+x2+..+xn)/n, (y1+y2+..yn)/n, (z1+z2+..+z3)/n]

`

I&#39;m able to perform the addition when I&#39;ve 2 list only and size is fixed using the below statement:
```
UNWIND(apoc.coll.zip([1,2,3], [4,5,6])) as output

RETURN COLLECT(apoc.coll.avg(output))
```
Output is 
```
[2.5, 3.5, 4.5]
```

But wasn&#39;t not able to compyte for dynamic number of *n* list. The size of list is constant for which avg needs to be computed.

**Neo4j Desktop Graph version**: 3.5.18 

**APOC LIbrary**: 3.5.0.12

Thanks in advance!

",
          "link": "https://stackoverflow.com/q/62450549",
          "creation_date": 1592485114,
          "answer_count": 1,
          "title": "Compute Avg of list value for each element in Neo4j",
          "uuid": 62450549,
          "view_count": 92
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:447"
      },
      {
        "identity": 5236,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "Team, 

I am trying to spin up neo4j container and neovis(node) container in a cloud server. The issue is when I provide the internal IP of the neo4j container for ``` const driver = neo4j.driver(&#39;bolt://neo4jcontainerIP&#39;, neo4j.auth.basic(&#39;neo4j&#39;, &#39;password&#39;)); ``` it cannot connect or fetch the data.

But when I provide a public IP of the host where neo4j is running ``` const driver = neo4j.driver(&#39;bolt://publicIP&#39;, neo4j.auth.basic(&#39;neo4j&#39;, &#39;password&#39;)); ``` it works without any issues


Can you please assist me how to pull the data into the neovis frontend using neo4j container IP? 

```
const neo4j = require(&#39;neo4j-driver&#39;);

const driver = neo4j.driver(&#39;bolt://localhost&#39;, neo4j.auth.basic(&#39;neo4j&#39;, &#39;password&#39;));

module.exports = driver;
```

Your help is greatly appreciated!! ",
          "link": "https://stackoverflow.com/q/66942415",
          "creation_date": 1617547472,
          "answer_count": 0,
          "title": "Unable to connect to neo4j bolt server using container IP",
          "uuid": 66942415,
          "view_count": 16
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5236"
      },
      {
        "identity": 5446,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have some events being sent from a Kafka topic to an existing Neo4j Database. The Database has already around 4000 labels and 11500 relationships. These events being sent from kafka should match their corresponding nodes automatically. Lets say:

There are 3 nodes that represent product a &amp; product b. 

the kafka topic publishes the status of the different products to neo4j:
product a: available, product b : blocked: product a: blocked, product a: shipped

the graph should be:

(product A)------&gt;(available)-----&gt;(blocked)----&gt;(shipped)

(product B)------&gt;(blocked)

I cannot figure out how to solve this. As far as I can do i get to ingest the events from kafka to neo4j, but after that i do not get to match them with their corresponding product. 

Thankyou very much.",
          "link": "https://stackoverflow.com/q/66250765",
          "creation_date": 1613600464,
          "answer_count": 0,
          "title": "how to automatically match events sent from kafka in Neo4j",
          "uuid": 66250765,
          "view_count": 14
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5446"
      }
    ]
  },
  {
    "t1": {
      "identity": 1683,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "graph-databases",
        "link": "https://stackoverflow.com/questions/tagged/graph-databases"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1683"
    },
    "t2": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "questions": [
      {
        "identity": 5127,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 67405907,
          "body_markdown": "I have company holding data with hierarchical structure by year. For example company A holds 50% of B, B holds 50% of C and D holds 50% of C. Each firm has their properties such as industry.

There are few write operations and mostly read. Specifically, starting from a set of nodes (root), extract the family tree by tracing down with certain percentage share threshold. There are several metrics of interest in the family tree.

For each node: 
1. the depth from the root
2. the product of share layer by layer from the root, e.g. A holds 0.5*0.5 = 25% of C.

For each level:
1. the distribution of share from each root
2. the distribution of industry

Note that there could be multiple roots for each node and we are interested in all.

For now, the data is stored in a relational database and the task described above is done through joining. Would a graph database such as neo4j be more suitable for the data and this task? The crux of the problem is to have a proper index so that joining is not necessary for each time. Any suggestion and pointer would be greatly appreciated.",
          "link": "https://stackoverflow.com/q/67363073",
          "creation_date": 1620011316,
          "answer_count": 2,
          "title": "Graph database or relational database for tree structure data",
          "uuid": 67363073,
          "view_count": 92
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5127"
      },
      {
        "identity": 321,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "Hello I have a graph db like this one: 
[![enter image description here][1]][1]

my wish is to retrieve all the nodes connected through the `r` relationship starting from a selected node. E.g.

if I select `a`, then I expect two rows as a response:

    a,b,c
    a,d

if I select `b` then I expect one row:

    b,c

I tried with `match p=(:a)-[:r*..]-&gt;() return p` but it returns this
[![enter image description here][2]][2]


and in python I get this that i don&#39;t know how to parse:

    &lt;Path start=&lt;Node id=93 labels=frozenset({&#39;a&#39;}) properties={&#39;name&#39;: &#39;A&#39;}&gt; end=&lt;Node id=94 labels=frozenset({&#39;b&#39;}) properties={&#39;name&#39;: &#39;B&#39;}&gt; size=1&gt;
    &lt;Path start=&lt;Node id=93 labels=frozenset({&#39;a&#39;}) properties={&#39;name&#39;: &#39;A&#39;}&gt; end=&lt;Node id=95 labels=frozenset({&#39;c&#39;}) properties={&#39;name&#39;: &#39;C&#39;}&gt; size=2&gt;
    &lt;Path start=&lt;Node id=93 labels=frozenset({&#39;a&#39;}) properties={&#39;name&#39;: &#39;A&#39;}&gt; end=&lt;Node id=96 labels=frozenset({&#39;d&#39;}) properties={&#39;name&#39;: &#39;D&#39;}&gt; size=1&gt;

&lt;br&gt;

Edit: I discovered function nodes() so I tried with `match p=(:a)-[:r*..]-&gt;() return nodes(p)` that returns kinda what I need:

[![enter image description here][3]][3]

but it still duplicates the path `a,b,c` in `a,b` and `a,b,c`. How can I remove the first row?


  [1]: https://i.stack.imgur.com/e4QzV.png
  [2]: https://i.stack.imgur.com/h3fj7.png
  [3]: https://i.stack.imgur.com/H62Ok.png",
          "link": "https://stackoverflow.com/q/63563077",
          "creation_date": 1598279444,
          "answer_count": 1,
          "title": "neo4j how to return all paths from a selected starting node",
          "uuid": 63563077,
          "view_count": 96
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:321"
      },
      {
        "identity": 4854,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 68438202,
          "body_markdown": "We have millions of users of can make millions of transactions between them.

Lets say there is a user_A who pays money to user_B on the daily basis. We have a relationship SEND_MONEY_TO between A and B nodes.

A ---SENDS_MONEY_TO---&gt; B

What will be the better design to accommodate this data in Neo4j.

**Option A**: We will create a new relationship edge every time a transaction happens.

**Option B**: We will keep a list of transactions as property of a same relationship edge and append the transaction details to existing list whenever a new transaction happens.

Our queries will look like:

a.) Find number of transaction between user_A and user_B in month of April 2021 where HDFC credit card is used.

b.) Find the total amount of transactions which involves user_A

We are open to any new approach as well.",
          "link": "https://stackoverflow.com/q/68436553",
          "creation_date": 1626679197,
          "answer_count": 2,
          "title": "Is it OK to have millions of directed relationships between two nodes in Neo4j? Will it add to latency in fetching the data?",
          "uuid": 68436553,
          "view_count": 55
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4854"
      },
      {
        "identity": 5007,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "Initially when I accessing the API with neo4j database it works properly but after some time when I try to access the API I got the error below:

```
Failed after retried for 6 times in 30000 ms. Make sure that your database is online and retry again.
```

I am using the code below for database connection in API:

```
var neo4jClient = new BoltGraphClient(new Uri(connectionUrl), Username, Password);
neo4jClient.ConnectAsync();
services.AddSingleton&lt;IBoltGraphClient&gt;(neo4jClient);
```",
          "link": "https://stackoverflow.com/q/67832244",
          "creation_date": 1622786946,
          "answer_count": 1,
          "title": "Failed after retried for 6 times in 30000 ms when accessing API with neo4j database",
          "uuid": 67832244,
          "view_count": 97
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5007"
      },
      {
        "identity": 5533,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m attempting to return a single node label as a property in a cypher query. I&#39;m using the GRANDstack, so I&#39;d like GraphQL to ask Neo4j for a list of nodes, each with the label as a property:
```
query GetPushNotificationsByUser($userId: ID!) {
    GetPushNotificationsByUser(userId: $userId) {
      id,
      label,
      title,
      message,
      status,
      externalUrl,
      createdAt {
        formatted
      }
    }
  }
```
I&#39;m attempting to use the `head()` and `labels()` functions for this, but so far unsuccessfully: 
```
MATCH (u:User {id: $userId})&lt;-[:NOTIFIES]-(pn:PushNotification {status: &#39;SENT&#39;})
WITH head(labels(pn)) as label, pn
RETURN pn
ORDER BY pn.createdAt DESC
```
AND
```
MATCH (u:User {id: $userId})&lt;-[:NOTIFIES]-(pn:PushNotification {status: &#39;SENT&#39;})
RETURN pn, head(labels(pn)) as label
ORDER BY pn.createdAt DESC
```
both return the &quot;PushNotifications&quot;, but sans the label property. Does anyone know how I can achieve this?",
          "link": "https://stackoverflow.com/q/65922459",
          "creation_date": 1611762036,
          "answer_count": 0,
          "title": "Neo4j/Cypher return the first element of the list of node labels as a property",
          "uuid": 65922459,
          "view_count": 51
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5533"
      }
    ]
  },
  {
    "t1": {
      "identity": 1682,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "cypher",
        "link": "https://stackoverflow.com/questions/tagged/cypher"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1682"
    },
    "t2": {
      "identity": 1684,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j-apoc",
        "link": "https://stackoverflow.com/questions/tagged/neo4j-apoc"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1684"
    },
    "questions": [
      {
        "identity": 591,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 61532475,
          "body_markdown": "I have a schema which looks like below:

1. A `customer` is linked to another `customer` with a relationship `SIMILAR` having `similarity score`.

   Example: `(c1:Customer)--&gt;(c2:Customer)`

2. An `Email` node is connected to each `customer` with relationship `MAIL_AT` with the following node properties:
 ```
  {
      &quot;active_email_address&quot;: &quot;a@mail.com&quot;,
      &quot;cibil_email_addresses&quot;: [
          &quot;b@mail.com&quot;, &quot;c@mail.com&quot;
      ]
  }
 ```
 Example: `(e1:Email)&lt;-[:MAIL_AT]-(c1:Customer)-[:SIMILAR]-&gt;(c2:Customer)-[:MAIL_AT]-&gt;(e2:Email)`

3. A `Risk` node with some risk-related properties (below) and is related to `customer` with relationship `HAS_RISK`:
 ```
   {
     &quot;f0_score&quot;: 870.0,
     &quot;pta_score&quot;: 430.0
   }
 ```
4. A `Fraud` node with some fraud-related properties (below) and is related to `customer` with relationship `IS_FRAUD`:
 ```
   {
     &quot;has_commited_fraud&quot;: true
   }
 ```

**My Objectives**:

1. To find the customers with common email addresses (irrespective of active and secondary)?

**My tentative solution:**
```
MATCH (email:Email)
WITH email.cibil_email_addresses + email.active_email_address AS emailAddress, email
UNWIND emailAddress AS eaddr
WITH DISTINCT eaddr AS deaddr, email
UNWIND deaddr AS eaddress
MATCH (customer:Customer)-[]-&gt;(someEmail:Email)
WHERE eaddress IN someEmail.cibil_email_addresses + someEmail.active_email_address
WITH eaddress, COLLECT(customer.customer_id) AS customers
RETURN eaddress, customers
```
**Problem:** It is taking forever to execute this. Working with lists will take time I understand, however, I&#39;m flexible to change the schema (If suggested). Should I break the email address into separate nodes? If yes, then how do I break `cibil_email_addresses` into different nodes as they can vary - *Should I create two nodes with different `cibil email addresses` and connect both of them to customer with relationship `HAS_CIBIL_EMAIL`? (Is this a valid schema design)*. Also, it is possible, a customer&#39;s `active_email_address` is present in other customer&#39;s `cibil_email_address`. I&#39;m trying to find a synthetic identity attack. PS: If there exists some `APOC` that can help achieve this and below, do suggest with example.

 2. In production, for a given customer with `email addresses`, `risk values`, `similarity score`, and also given other customers may or may not be tagged with `fraud_status`, I want to check whether this new person will fall in a fraud ring or not. PS: If I need to use any `gds` to solve this, please suggest with examples.

 3. If I were to do this same exercise with some other node such as `Address` which may be partially matching and will be having same list of historical addresses in a list, what should be my ideal approach? 


I know, I&#39;m tagging someone in my question, but that person only seems to be active with respect to Cypher on StackOverflow. **@cybersam** any help?
Thanks.",
          "link": "https://stackoverflow.com/q/61519481",
          "creation_date": 1588236746,
          "title": "Cypher query for list pattern",
          "answer_count": 1,
          "uuid": 61519481,
          "view_count": 39
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:591"
      },
      {
        "identity": 4623,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 69272967,
          "body_markdown": "I want to match blogs that have most like interaction with certain tags (in the example I used dog) but posted in it less than 10 times.

How can I achieve that?

Currently, I get this error message

```
Invalid use of aggregating function count(...) in this context (line 6, column 7 (offset: 210))
&quot;WHERE COUNT(posted) &lt; 10&quot;
``` 
# Query
```
MATCH (b:Blog)-[r:liked]-(p:Post)-[:tagged]-(t:Tag)
WHERE t.content = &quot;dog&quot;
WITH b, COUNT(r) as interaction_count

MATCH (b:Blog)-[posted:posted_by]-(:Post)-[:tagged]-(t:Tag)
WHERE COUNT(posted) &lt; 10

RETURN b, interaction_count
ORDER BY interaction_count DESC
LIMIT 10
```",
          "link": "https://stackoverflow.com/q/69272255",
          "creation_date": 1632241098,
          "answer_count": 1,
          "title": "Return &#39;biggest fan of a tag&#39; neo4j",
          "uuid": 69272255,
          "view_count": 12
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4623"
      },
      {
        "identity": 275,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 63857994,
          "body_markdown": "There is a graph, each of its nodes contains property `communityId` to indicate which community the node belongs to. The nodes are connected with `LINK` relationship, which contains `weight` property.

What I want is to merge those nodes of the same community into a big node. The links between those big nodes (aka. communities) must be synthesized/combined **reasonably**: the `weight` property of the link must be added up, based on individual nodes in each community connected to the other. Direction of the link must be respected.

In the result graph, I will only see connected *community* nodes.

The closest function is [Merge Nodes](https://neo4j.com/labs/apoc/4.1/graph-updates/graph-refactoring/merge-nodes/), function `apoc.refactor.mergeNodes()`. However, I&#39;m dissatisfied with the result because:

+ Problem 1: The result community nodes have self-link.
+ Problem 2: Weights of the links are not combined although the documentation says so.

Problem 1 can be fixed by writing one more Cypher to remove self-links. But problem 2 can only be tackled with low-level access to the Graph (like `mergeNodes()` above).

Is there any elegant approach to have my desired graph (*community* nodes) in **one go**? Or at least, problem 2 must be fixed somehow.

## Reproducibility

Graph:

```
CREATE (a:User {name: &quot;A&quot;, communityId: 2}), (b:User {name: &quot;B&quot;, communityId: 2}), (c:User {name: &quot;C&quot;, communityId: 2}), (x:User {name: &quot;X&quot;, communityId: 1}), (y:User {name: &quot;Y&quot;, communityId: 1}), (z:User {name: &quot;Z&quot;, communityId: 1}), (w:User {name: &quot;W&quot;, communityId: 1}), (a)-[:LINK {weight: 1}]-&gt;(b), (b)-[:LINK {weight: 1}]-&gt;(c), (c)-[:LINK {weight: 1}]-&gt;(a), (b)-[:LINK {weight: 1}]-&gt;(z), (z)-[:LINK {weight: 1}]-&gt;(x), (z)-[:LINK {weight: 1}]-&gt;(w), (w)-[:LINK {weight: 1}]-&gt;(y), (y)-[:LINK {weight: 1}]-&gt;(x), (b)-[:LINK {weight: 1}]-&gt;(w)
```

[![enter image description here][1]][1]

Cypher:

```
MATCH (n:User)
WITH n.communityId AS communityId, COLLECT(n) AS nodes
CALL apoc.refactor.mergeNodes(nodes, {
    properties: {
        name: &#39;combine&#39;,
        communityId: &#39;discard&#39;,
        weight: &#39;combine&#39;
    },
    mergeRels: true
})
YIELD node
RETURN node
```

[![enter image description here][2]][2]

## System Requirement

- Windows 8.1 x64
- Neo4j Desktop v1.3.4 (Engine v4.1.1.)
- APOC v4.1.0.2
- Graph Data Science Library v1.3.2


  [1]: https://i.stack.imgur.com/FENx4.png
  [2]: https://i.stack.imgur.com/a40RR.png",
          "link": "https://stackoverflow.com/q/63854932",
          "creation_date": 1599862320,
          "answer_count": 1,
          "title": "How to merge nodes of the same community with Cypher in Neo4j?",
          "uuid": 63854932,
          "view_count": 150
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:275"
      },
      {
        "identity": 123,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "neo4j version 4.2.0

apoc version 4.2.0.0

After update to neo4j 4.2 not work apoc functions from reader role, return error:

&gt; message: Executing a user defined function is not allowed for user
&gt; &#39;User&#39; with roles [PUBLIC, reader].

Yes, it&#39;s qute simple just find in docs need to run script for grant privileges:

    GRANT EXECUTE FUNCTION apoc.* ON DBMS TO reader

But here start real problems it&#39;s return error:

&gt; This operation is not supported while running in compatibility mode
&gt; with version Neo4j 4.1

Can&#39;t find anything about this *compatibility* in google or in config, run with spicifig cypher version like this not help:

    CYPHER 4.2 GRANT EXECUTE FUNCTION apoc.* ON DBMS TO reader
    ",
          "link": "https://stackoverflow.com/q/64994974",
          "creation_date": 1606252689,
          "answer_count": 0,
          "title": "After update to neo4j 4.2 not work apoc functions from reader role",
          "uuid": 64994974,
          "view_count": 53
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:123"
      },
      {
        "identity": 392,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "
We have two seperate files loading neo4j using APOC. The first, loads the nodes up and that seems to be working correctly. Now I need to load the relationships. I have this json file coming in. 

    {
	&quot;0&quot;: {
		&quot;child&quot;: &quot;54690&quot;,
		&quot;compile&quot;: &quot;webgoat.combined.source&quot;,
		&quot;parent&quot;: &quot;0&quot;,
		&quot;tree&quot;: &quot;runs&quot;
	},
	&quot;1&quot;: {
		&quot;child&quot;: &quot;2&quot;,
		&quot;compile&quot;: &quot;webgoat.combined.source&quot;,
		&quot;parent&quot;: &quot;1&quot;,
		&quot;tree&quot;: &quot;calls&quot;
	},

parent and child are the two nodes that need to be connected. The name of the relationship needs to be based on **tree**, and qualified based on the **compile** field. In other words, I need the relationship created only where parent-child share the same compile string. 

This is the APOC command I have so far:

        with graphDB_Driver.session() as ses:
            ses.run(&quot;UNWIND $batch AS row MATCH (a:ProgNode{parent:row.a}) MATCH (b:ProgNode{child:row.b}) CALL apoc.merge.relationship(a, &#39;TREE&#39;, {}, apoc.map.removeKeys(properties(row), [&#39;parent&#39;, &#39;child&#39;]), b) YIELD rel RETURN 1&quot;, batch=BATCH[&quot;batch&quot;])

 

I have tried substituting a variety of variable names for &quot;TREE&quot; including row.tree, tree:row.a but nothing seems to work. I have verified that BATCH[&#39;batch&#39;] below contains the same data . 

    [{&quot;child&quot;: &quot;54690&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;0&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 0}, {&quot;child&quot;: &quot;2&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1&quot;, &quot;tree&quot;: &quot;calls&quot;, &quot;from&quot;: 1}, {&quot;child&quot;: &quot;101&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;100&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 100}, {&quot;child&quot;: &quot;1001&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1000&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 1000}, {&quot;child&quot;: &quot;10001&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10000&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10000}, {&quot;child&quot;: &quot;10004&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10003&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10003}, {&quot;child&quot;: &quot;10009&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10004&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10004}, {&quot;child&quot;: &quot;10007&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10005&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10005}, {&quot;child&quot;: &quot;10008&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10007&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10007}, {&quot;child&quot;: &quot;1005&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1001&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 1001}, {&quot;child&quot;: &quot;1003&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1002&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 1002}, {&quot;child&quot;: &quot;10028&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10022&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10022}, {&quot;child&quot;: &quot;10025&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10023&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10023}, {&quot;child&quot;: &quot;10026&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10025&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10025}, {&quot;child&quot;: &quot;10041&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10028&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10028}, {&quot;child&quot;: &quot;10034&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10029&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10029}, {&quot;child&quot;: &quot;10031&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10030&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10030}, {&quot;child&quot;: &quot;10040&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10035&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10035}, {&quot;child&quot;: &quot;10037&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10036&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10036}, {&quot;child&quot;: &quot;10051&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10041&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10041}, {&quot;child&quot;: &quot;10044&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10042&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10042}, {&quot;child&quot;: &quot;10045&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10044&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10044}, {&quot;child&quot;: &quot;10046&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10045&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10045}, {&quot;child&quot;: &quot;10050&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10048&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10048}, {&quot;child&quot;: &quot;10052&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10051&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10051}, {&quot;child&quot;: &quot;10071&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10052&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10052}, {&quot;child&quot;: &quot;10054&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10053&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10053}, {&quot;child&quot;: &quot;10061&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10054&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10054}, {&quot;child&quot;: &quot;10057&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10055&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10055}, {&quot;child&quot;: &quot;10059&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10057&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10057}, {&quot;child&quot;: &quot;10060&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10059&quot;, &quot;tree&quot;: &quot;calls&quot;, &quot;from&quot;: 10059}, {&quot;child&quot;: &quot;1007&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1006&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 1006}, {&quot;child&quot;: &quot;10063&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10062&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10062}, {&quot;child&quot;: &quot;10065&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10063&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10063}, {&quot;child&quot;: &quot;10067&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10065&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10065}, {&quot;child&quot;: &quot;10068&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10067&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10067}, {&quot;child&quot;: &quot;10070&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10068&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10068}, {&quot;child&quot;: &quot;1009&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1007&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 1007}, {&quot;child&quot;: &quot;10072&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10071&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10071}, {&quot;child&quot;: &quot;10074&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10072&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10072}, {&quot;child&quot;: &quot;10102&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10088&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10088}, {&quot;child&quot;: &quot;10090&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10089&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10089}, {&quot;child&quot;: &quot;1011&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1009&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 1009}, {&quot;child&quot;: &quot;10093&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10091&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10091}, {&quot;child&quot;: &quot;10094&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10093&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10093}, {&quot;child&quot;: &quot;10097&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10095&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10095}, {&quot;child&quot;: &quot;10098&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10097&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10097}, {&quot;child&quot;: &quot;10100&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10098&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10098}, {&quot;child&quot;: &quot;103&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;101&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 101}, {&quot;child&quot;: &quot;10261&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10102&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10102}, {&quot;child&quot;: &quot;10107&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10103&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10103}, {&quot;child&quot;: &quot;10106&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10105&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10105}, {&quot;child&quot;: &quot;10129&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10107&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10107}, {&quot;child&quot;: &quot;10115&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10108&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10108}, {&quot;child&quot;: &quot;10110&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10109&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10109}, {&quot;child&quot;: &quot;1013&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1011&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 1011}, {&quot;child&quot;: &quot;10114&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10112&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10112}, {&quot;child&quot;: &quot;10116&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10115&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10115}, {&quot;child&quot;: &quot;10117&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10116&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10116}, {&quot;child&quot;: &quot;10118&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10117&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10117}, {&quot;child&quot;: &quot;10126&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10119&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10119}, {&quot;child&quot;: &quot;10121&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10120&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10120}, {&quot;child&quot;: &quot;10125&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10123&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10123}, {&quot;child&quot;: &quot;10127&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10126&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10126}, {&quot;child&quot;: &quot;10128&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10127&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10127}, {&quot;child&quot;: &quot;10138&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10129&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10129}, {&quot;child&quot;: &quot;10131&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10130&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10130}, {&quot;child&quot;: &quot;10137&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10133&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10133}, {&quot;child&quot;: &quot;10135&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10134&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10134}, {&quot;child&quot;: &quot;10136&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10135&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10135}, {&quot;child&quot;: &quot;10139&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10138&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10138}, {&quot;child&quot;: &quot;10151&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10139&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10139}, {&quot;child&quot;: &quot;1045&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;1014&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 1014}, {&quot;child&quot;: &quot;10141&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10140&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10140}, {&quot;child&quot;: &quot;10143&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10141&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10141}, {&quot;child&quot;: &quot;10145&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10143&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10143}, {&quot;child&quot;: &quot;10146&quot;, &quot;compile&quot;: &quot;webgoat.combined.source&quot;, &quot;parent&quot;: &quot;10145&quot;, &quot;tree&quot;: &quot;runs&quot;, &quot;from&quot;: 10145}, 

Thoughts ?",
          "link": "https://stackoverflow.com/q/62867601",
          "creation_date": 1594598371,
          "answer_count": 1,
          "title": "How do I qualify and name a relationship in Neo4j APOC?",
          "uuid": 62867601,
          "view_count": 51
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:392"
      }
    ]
  },
  {
    "t1": {
      "identity": 1682,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "cypher",
        "link": "https://stackoverflow.com/questions/tagged/cypher"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1682"
    },
    "t2": {
      "identity": 1683,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "graph-databases",
        "link": "https://stackoverflow.com/questions/tagged/graph-databases"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1683"
    },
    "questions": [
      {
        "identity": 4867,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "[![enter image description here][1]][1]
Can someone please provide me cypher query for the above cell. It&#39;s a representation of the data I have. Here questions are nodes and Answers are properties and recommendation is also a node. The problem I am facing is, there could be possibilities of Question2 or 3 missing along with it&#39;s answer. Like question 2 and 3 are follow up of previous question, like question 3 is based on the response to the Question 2. When I load it, there are so many missing Nan, so I had to use &quot;COALESCE&quot; to read the line, but the nodes are breaking, like question1 should be connected to question 2 and question 2 should be connected to question 3 and then the recommendations. If there are no question 2 or 3, question1 should be directly connected to recommendation.

Because there are multiple responses for a question, nodes are created with Question as &quot;NA&quot;(because i have used COALESCE).

Thanks in advance

  [1]: https://i.stack.imgur.com/IBVqn.png",
          "link": "https://stackoverflow.com/q/68377355",
          "creation_date": 1626262725,
          "title": "Neo4j loading CSV with missing cells",
          "answer_count": 0,
          "uuid": 68377355,
          "view_count": 15
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4867"
      },
      {
        "identity": 4623,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 69272967,
          "body_markdown": "I want to match blogs that have most like interaction with certain tags (in the example I used dog) but posted in it less than 10 times.

How can I achieve that?

Currently, I get this error message

```
Invalid use of aggregating function count(...) in this context (line 6, column 7 (offset: 210))
&quot;WHERE COUNT(posted) &lt; 10&quot;
``` 
# Query
```
MATCH (b:Blog)-[r:liked]-(p:Post)-[:tagged]-(t:Tag)
WHERE t.content = &quot;dog&quot;
WITH b, COUNT(r) as interaction_count

MATCH (b:Blog)-[posted:posted_by]-(:Post)-[:tagged]-(t:Tag)
WHERE COUNT(posted) &lt; 10

RETURN b, interaction_count
ORDER BY interaction_count DESC
LIMIT 10
```",
          "link": "https://stackoverflow.com/q/69272255",
          "creation_date": 1632241098,
          "answer_count": 1,
          "title": "Return &#39;biggest fan of a tag&#39; neo4j",
          "uuid": 69272255,
          "view_count": 12
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4623"
      },
      {
        "identity": 4968,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am trying to create nodes by loading a csv file. Since I wanted to exclude some columns I decided to use `apoc.load.csv` instead of the simpler `LOAD CSV` command.

I wanted to have all the columns present as corresponding property value for the nodes. However I am not able to figure out how to do it. When the columns are less you can hardcode it, but in my real dataset I have more than 60 columns so I was hoping that there would be a programmatic way to achieve what I want to do.

Demo Dataset you can use `data.csv` -
```csv
name,age,beverage,country_from,fruit
Selma,9,Soda,RU,Apple
Rana,12,Tea,USA,Orange
Selina,19,Cola,CA,Guava
```
What I have tried so far that doesn&#39;t work yet -

```
CALL apoc.load.csv(&#39;data.csv&#39;, {header:true, ignore:[&#39;beverage&#39;], 
mapping:{
    age: {type:&#39;int&#39;},
    country_from: {name: &quot;country&quot;}
    }
})
YIELD map as row
CREATE (e:Entity $row)
CREATE (f:Fruit {name: row.fruit})
CREATE (c:Country {name: row.country_from})
MERGE (e:Entity)-[:EATS]-&gt;(f:Fruit)
MERGE (e:Entity)-[:IS_FROM]-&gt;(c:Country)
RETURN e,c,f
```
**Expected Output**:  
The graphdatabase has the Entity nodes with properties `name`,`age`,`country`,`fruit`

Initially I was using `{row}` but then I got the error as described [here](https://stackoverflow.com/questions/65246248/cyphersyntaxerrorthe-old-parameter-syntax-param-is-no-longer-supported-ple)
```
The old parameter syntax `{param}` is no longer supported. Please use `$param` instead
```
so I switched to using `$row` but then I get -
```
Expected parameter(s): row
```

I have followed the ideas from the following links -
1. https://neo4j-contrib.github.io/neo4j-apoc-procedures/3.4/export-import/load-csv/
2. https://neo4j.com/labs/apoc/4.1/import/load-csv/",
          "link": "https://stackoverflow.com/q/67987359",
          "creation_date": 1623764199,
          "answer_count": 0,
          "title": "How to pass the whole map as a property when using apoc.load.csv while creating nodes?",
          "uuid": 67987359,
          "view_count": 37
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4968"
      },
      {
        "identity": 436,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 62543406,
          "body_markdown": "Currently this is the data stored in the database

    Org Name   Org ID
    A            1
    B            2
    C            5
    D            9  

I&#39;m trying to combine these 2 queries:

    MATCH (n:Org)
    WHERE n.id in [1,2]
    RETURN n.name as group1_name, n.id as group1_id

    MATCH (n:Org)
    WHERE n.id in [5,9]
    RETURN n.name as group2_name, n.id as group2_id

I need the result to be shown like this:

    group1_id   group1_name   group2_id   group1_name
    1                A           5          C
    2                B           9          D

  ",
          "link": "https://stackoverflow.com/q/62533423",
          "creation_date": 1592910822,
          "title": "Combine two cypher queries",
          "answer_count": 1,
          "uuid": 62533423,
          "view_count": 18
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:436"
      },
      {
        "identity": 5196,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am trying to pass on the parameter to the cypher query in a function but it is not returning the results as expected. First error was `ClientError: {code: Neo.ClientError.Statement.ParameterMissing} {message: Expected parameter(s): x}` I checked it on another forum where I also had to pass the parameter along with query run session I did so and error disappeared but still it didn&#39;t get the results as expected and returned the empty nodes. 

In the graph db the nodes are connected with 4 types of relationships with an ids. 

This is what I have tried so far: 

    def get_objects(x):
        query = &#39;&#39;&#39; MATCH (p)-[r]-&gt;(a) where r.id = $x RETURN p.id; &#39;&#39;&#39; 
        resultNodes = session.run(query, x = x)
        df = DataFrame(resultNodes)
        print(df)
        return df
    
    def find_max_1():
        authors,terms,venues,papers=0,0,0,0
        authors=get_objects(1).max()
        terms=get_objects(2).max()
        venues=get_objects(3).max()
        papers=get_objects(4).max()
        return authors,terms,venues,papers
    
    def main():
        
        m = m=find_max_1()
        
    
    if __name__ == &quot;__main__&quot;:
        
        main()
and the output is: 

    Empty DataFrame
    Columns: []
    Index: []
    Empty DataFrame
    Columns: []
    Index: []
    Empty DataFrame
    Columns: []
    Index: []
    Empty DataFrame
    Columns: []
    Index: []

I am unable to identify what&#39;s wrong with this.

Any kind of help in right direction would be appreciated. 

Thanks in advance. ",
          "link": "https://stackoverflow.com/q/67055300",
          "creation_date": 1618217123,
          "answer_count": 2,
          "title": "Neo4j cypher query doesn&#39;t return the results as expected into pandas DataFrame",
          "uuid": 67055300,
          "view_count": 49
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5196"
      }
    ]
  },
  {
    "t1": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "t2": {
      "identity": 1699,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "python",
        "link": "https://stackoverflow.com/questions/tagged/python"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1699"
    },
    "questions": [
      {
        "identity": 4736,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 68843437,
          "body_markdown": "I&#39;ve been using `neo4j` with `py2neo` for a couple of weeks now, and up to now it was fine to just do single node transactions, so I would have different node types
```python
class NodeA(GraphObject):
  ...

class NodeB(GraphObject):
  ...

# create some nodes from data and simply save them one by one
for data in dataset:
  node_a = NodeA(data)
  node_b = NodeB(data)

  if x:
    node_a.related_to_b.add(node_b)

  g.merge(node_b)
  g.merge(node_a)
```
Nothing fancy. However, I&#39;m starting to get more nodes and connections, and single transactions don&#39;t really work anymore, as expected. I&#39;ve been looking for ways to do bulk inserts, but can&#39;t find any good ressources. The best I&#39;ve managed to accomplish is using `unwind_merge_nodes_query`, which has two issues:
1. isn&#39;t that fast (~5 seconds for 700 very basic nodes on my laptop)
2. edges need to be handled separately
3. it requires keeping track of all the node ids to be able to handle edge connections

I&#39;ve been writing functions to handle the above mentioned points, but I feel like I&#39;m missing something and that there&#39;s a simpler way to handle batches of data
",
          "link": "https://stackoverflow.com/q/68833984",
          "creation_date": 1629295648,
          "answer_count": 1,
          "title": "Correct way to bulk insert / merge nodes and edges",
          "uuid": 68833984,
          "view_count": 21
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4736"
      },
      {
        "identity": 5331,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am using **Neo4j Rest API** to successfully create nodes &amp; relationships on the **Neo4j server**. But to execute a query, I need to manually type the query on the search box &amp; hit enter. Is there a way to **load this query**(saved on some file) **on the search box** using any tool, library, or trick? 
1. I tried **DOM manipulation** to make the query appear on the Search Box. It&#39;s appearing but not getting saved internally. And that&#39;s why when I hit enter nothing gets executed.
&lt;br&gt;
Eg - To enter a simple query on Neo4j platform:
```
match (n) return n
```
I tried inserting spans under the &quot;presentation&quot; span
```
&lt;span role=&quot;presentation&quot; style=&quot;padding-right: 0.1px;&quot;&gt;
  &lt;span class=&quot;cm-keyword&quot;&gt;match&lt;/span&gt; 
  &lt;span class=&quot;cm-operator&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;cm-variable&quot;&gt;n&lt;/span&gt;
  &lt;span class=&quot;cm-operator&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;cm-keyword&quot;&gt;return&lt;/span&gt;
  &lt;span class=&quot;cm-variable&quot;&gt;n&lt;/span&gt;
&lt;/span&gt;
```
2. I tried using **pyautoGUI** in python. It detects where&#39;s a text field is present on the page by training it with various similar photos. And then it can inserts the data into the text field. But this way, it takes a lot of time.

Is there any other way to post data on a search box?",
          "link": "https://stackoverflow.com/q/66624037",
          "creation_date": 1615721771,
          "answer_count": 0,
          "title": "How to post data to search box in Neo4j graph platform",
          "uuid": 66624037,
          "view_count": 15
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5331"
      },
      {
        "identity": 5143,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 67289797,
          "body_markdown": "I&#39;m trying to use a python 3 script that requires the &quot;neo4j&quot; module. I already installed the module in python 3, but when try to run the script again, it keeps asking for the module.

When try to run the program that requires neo4j module:

    c:\Users\user1\Downloads\PlumHound-master&gt;python3 PlumHound.py -h
    Traceback (most recent call last):
      File &quot;PlumHound.py&quot;, line 12, in &lt;module&gt;
        import lib.phTasks
      File &quot;c:\Users\user1\Downloads\PlumHound-master\lib\phTasks.py&quot;, line 12, in &lt;module&gt;
        from neo4j import GraphDatabase
    ModuleNotFoundError: No module named &#39;neo4j&#39;

When I try to install the module:

    c:\Users\user1\Downloads\PlumHound-master&gt;python3 -m pip install neo4j
    Requirement already satisfied: neo4j in c:\users\user1\downloads\plumhound-master (4.2.1)
    Requirement already satisfied: pytz in c:\users\user1\appdata\local\programs\python\python38-32\lib\site-packages (from neo4j) (2021.1)


Does anyone know or have an idea about why this might be happening, and how I can fix it? PD: The device is offline and i installed the module manually with pip.",
          "link": "https://stackoverflow.com/q/67289546",
          "creation_date": 1619551983,
          "title": "python asking me for installed modules",
          "answer_count": 1,
          "uuid": 67289546,
          "view_count": 32
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5143"
      },
      {
        "identity": 5038,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have a problem that is probably quite simple, but I can&#39;t find solutions by myself...

I run two docker containers with docker-compose, one is a python server with fastapi, and another one the neo4j official image, with auth disabled (for dev environment)
Here the piece of code that connect the db:


```
    def __new__(cls, settings: Neo4jSettings, *args, **kwargs):
        try:
            cls.driver = GraphDatabase.driver(settings.neo4j_url())
            log.info(f&#39;Connected as &quot;{settings.neo4j_user}&quot; on {settings.neo4j_url()}&#39;)

        except exceptions.ServiceUnavailable as err:
            log.error(f&#39;Service Unavailable: {err}&#39;)
        # other error handling
```
ON MY LOCAL MACHINE: everything work as expected: when the database is running, i see the `connected ...` message, and all is working fine. when i shutdown the database, the neo4j diver raise a `Service Unavailable`, and i display the error.

ON DOCKER: All works as expected when the two containers are running, with the proper database url.
BUT if i change the url to a random one, or even if i shutdown the database container, the `connected ...` message is displayed.
Look like the neo4j driver **don&#39;t raise any exception** ... but and can&#39;t find a reason for that.

Here my Dockerfile:

```dockerfile
FROM python:3.7-slim # tried with 3.9 too  

WORKDIR /app


ENV VIRTUAL_ENV=/opt/venv
RUN python3 -m venv $VIRTUAL_ENV
ENV PATH=&quot;$VIRTUAL_ENV/bin:$PATH&quot;

COPY requirements.txt .

RUN pip install --upgrade pip
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD [&quot;uvicorn&quot;, &quot;main:api&quot;, &quot;--reload&quot; ,&quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]
```

Thanks you, and forgive me for my english ... ",
          "link": "https://stackoverflow.com/q/67738292",
          "creation_date": 1622202634,
          "answer_count": 0,
          "title": "Neo4J python driver doesn&#39;t raise errors when ruuning into a docker container",
          "uuid": 67738292,
          "view_count": 53
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5038"
      },
      {
        "identity": 5025,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m developing a **Python** app based on [Neo4j](https://neo4j.com/), and I&#39;m facing a challenge to write unit-tests in isolation from the Neo4j database, so I can run my unit-tests without depending on starting a full-blown database.

The Neo4j **Java** SDK includes an [&quot;In-Memory / Impermanent database&quot;](http://javadox.com/com.github.jasoma/neo4j-memorydb/3.1.1/org/neo4j/test/TestGraphDatabaseFactory.html)

Unfortunately, the [Python driver](https://neo4j.com/developer/python/) doesn&#39;t have that.

# Ideas

## Mocks

I considered mocking the database, however you [shouldn&#39;t mock what you don&#39;t own](https://github.com/testdouble/contributing-tests/wiki/Don%27t-mock-what-you-don%27t-own).
Especially third-party libraries.

As I want my unit-test to be reliable and follow a good design, I don&#39;t want to follow this path.

## Ports and Adapters

From a software architecture standpoint, integrating a third-party library like Neo4j should be done following the Ports and Adapters pattern.
This will give me the following benefits

- decouple my business logic from the graph logic
- have a clearly defined contract (port) that adapters have to implement
- having a Fake Neo4j adapter implementation, to be passed to my business logic for unit tests

This is promising, but I&#39;m overwhelmed by the amount of code to write.

Example code with the official Neo4j driver
~~~Python
driver = GraphDatabase.driver(&quot;bolt://localhost:7687&quot;)
with driver.session() as session:
    query = &quot;&quot;&quot;MATCH (u:USER)
             WHERE u.name = $name
             RETURN u&quot;&quot;&quot;
    cursor = session.run(query, parameters={&#39;name&#39;, &#39;Alfred&#39;})
    for result in cursor:
        acc_type = result[&#39;u&#39;][&#39;account_type&#39;]
        return acc_type
~~~

Example &quot;Ports and Adapters&quot; implementation

Defining the API (Port)
~~~Python
from abc import ABC, abstractmethod

class AbstractGraphService(ABC):
    def __init__(url: str):
        pass

    @abstractmethod
    def __enter__():
        &quot;&quot;&quot;returns a session&quot;&quot;&quot;
        pass

    @abstractmethod
    def __exit__(*args):
        &quot;&quot;&quot;close session object&quot;&quot;&quot;
        pass


class AbstractSession(ABC):

    @abstractmethod
    def run(self, query, parameters):
        &quot;&quot;&quot;execute a cypher query&quot;&quot;&quot;
        pass
~~~

➡️ how can I write a fake, in-memory implementation ? Am I supposed to write a Fake Cypher-execution engine as well ?

➡️ with the API demonstrated above, I haven&#39;t decoupled my Cypher queries from my business logic code

➡️ Is there a better road to follow to unit-test my code ?

Thank you for your suggestions",
          "link": "https://stackoverflow.com/q/67772390",
          "creation_date": 1622458483,
          "answer_count": 1,
          "title": "How to unit-test code depending on a complex graph database interaction",
          "uuid": 67772390,
          "view_count": 33
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5025"
      }
    ]
  },
  {
    "t1": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "t2": {
      "identity": 1718,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "spring-data-neo4j",
        "link": "https://stackoverflow.com/questions/tagged/spring-data-neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1718"
    },
    "questions": [
      {
        "identity": 5078,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 67572392,
          "body_markdown": "I&#39;m trying to port my legacy code to the latest version of Spring Data Neo4j and unable to find the following annotation:

    @Properties (org.neo4j.ogm.annotation.Properties)


What should be used instead of this?",
          "link": "https://stackoverflow.com/q/67555768",
          "creation_date": 1621162481,
          "answer_count": 1,
          "title": "Spring Data Neo4j @Properties annotation",
          "uuid": 67555768,
          "view_count": 52
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5078"
      },
      {
        "identity": 5499,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 66005163,
          "body_markdown": "I am trying to implement a neo4j `@ConvertWith` on a list property.

    @ConvertWith(converter = &quot;SomeConverter.class&quot;) 
    List&lt;CustomObject&gt; customObject;

I see that the SomeConverter should impl -&gt;

    implements Neo4jPersistentPropertyConverter&lt;List&lt;CustomObject&gt;&gt;
but i cant get the conversion to work.. it always seems to ask for the required id property in the CustomObject

    java.lang.IllegalStateException: Required identifier property not found for class
It might not even go into my converter? 

Question: Whats the correct way to implement a converter for a list of objects?",
          "link": "https://stackoverflow.com/q/65993141",
          "creation_date": 1612184300,
          "answer_count": 1,
          "title": "Spring Data Neo4j 6 @ConvertWith implementation",
          "uuid": 65993141,
          "view_count": 157
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5499"
      },
      {
        "identity": 4965,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "Actuator health endpoint in my Spring boot application shows:

    &quot;org.neo4j.driver.exceptions.AuthenticationException: Unsupported authentication token, scheme &#39;none&#39; is only allowed when auth is disabled.&quot;

Neo4j is running, application is working properly. What may be wrong with Spring Boot Actuator?",
          "link": "https://stackoverflow.com/q/67994384",
          "creation_date": 1623797680,
          "answer_count": 0,
          "title": "Neo4j Spring Boot Actuator health and Unsupported authentication token, scheme &#39;none&#39; is only allowed when auth is disabled",
          "uuid": 67994384,
          "view_count": 24
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4965"
      },
      {
        "identity": 4960,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have following classes:

    public interface Label {
      String getValue();
    }
    
    @Node
    @Data
    public class SimpleLabel implements Label {
      @Id
      @GeneratedValue
      private Long id;
      private String value;
    
      @Relationship(value = &quot;JE&quot;)
      private Set&lt;SimpleLabel&gt; labels = new HashSet&lt;&gt;();
    
      public void addLabel(SimpleLabel label){
        labels.add(label);
      }
    }
    
    @Node
    @Data
    public class HyperLabel implements Label {
      @Id
      @GeneratedValue
      private Long id;
    
      @Relationship(value = &quot;JE&quot;)
      private Set&lt;Label&gt; labels = new HashSet&lt;&gt;();
    
      public void addLabel(Label label){
        labels.add(label);
      }
    
      @Override
      public String getValue() {
        return labels.stream().map(Label::getValue).collect(Collectors.joining(&quot;; &quot;));
      }
    }

and this is the query I&#39;m using:

      @Query(&quot;MATCH (h:HyperLabel)-[r:JE]-(s:SimpleLabel) WHERE ID(h)=$id RETURN h,COLLECT(r),COLLECT(s)&quot;)
      Optional&lt;HyperLabel&gt; getById(Long id);

The problem, I&#39;m having is that `labels` collection that is returned by query is empty. But if I make a slight change in the code of `HyperLabel` class (change `Set&lt;Label&gt;` to `Set&lt;SimpleLabel&gt;`), then it works.

Is there any way to make it work with `Label` interface, since children of `HyperLabel` can be both `HyperLabel` and `SimpleLabel` instances?
",
          "link": "https://stackoverflow.com/q/68000851",
          "creation_date": 1623839003,
          "answer_count": 0,
          "title": "Spring data neo4j - polymorphic children collection",
          "uuid": 68000851,
          "view_count": 9
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4960"
      },
      {
        "identity": 5110,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 67470908,
          "body_markdown": "I have a complex cypher, When I don&#39;t use &quot;order by&quot; I get a pretty fast response but when I use &quot;order by&quot; it is incredibly slow. I have an b tree index on my order attribute(score of the movie which is PageRank algorithm score). I added the cypher.

``` 
MATCH (m:Movie)
WHERE m.release &gt; &#39;0&#39; AND m.imdbVoteAverage &gt; 0 AND
CASE WHEN NOT [] = [] THEN any(title in [] WHERE toLower(m.title) CONTAINS title OR toLower(m.originalTitle) CONTAINS title) ELSE TRUE END
WITH m AS m
MATCH (m)-[:HAS_GENRE]-&gt;(genre: Genre)
WHERE CASE WHEN NOT [&#39;komedi&#39;] = [] THEN any(genreName in [&#39;komedi&#39;] WHERE toLower(genre.name) CONTAINS genreName) ELSE TRUE END
MATCH (m)&lt;-[acted:ACTED_IN]-(actor: Person)
WHERE CASE WHEN NOT [] = [] THEN any(actorName in [] WHERE toLower(actor.name) CONTAINS actorName) ELSE TRUE END AND
CASE WHEN NOT [] = [] THEN any(characterName in [] WHERE any(cname in acted.characterNames WHERE toLower(cname) CONTAINS characterName)) ELSE TRUE END
MATCH (m) -[:HAS_KEYWORDS]-&gt;(keyword: Keyword)
WHERE CASE WHEN NOT [] = [] THEN any(keywordName in [] WHERE toLower(keyword.name) CONTAINS keywordName) ELSE TRUE END
MATCH (m)&lt;-[:PRODUCED]-(producer: Person)
WHERE CASE WHEN NOT [] = [] THEN any(producerName in [] WHERE toLower(producer.name) CONTAINS producerName) ELSE TRUE END
MATCH (m)&lt;-[:DIRECTED]-(director: Person)
WHERE CASE WHEN NOT [] = [] THEN any(directorName in [] WHERE toLower(director.name) CONTAINS directorName) ELSE TRUE END
MATCH (m)&lt;-[:WRITTEN]-(writer: Person)
WHERE CASE WHEN NOT [] = [] THEN any(writerName in [] WHERE toLower(writer.name) CONTAINS writerName) ELSE TRUE END
MATCH (m)&lt;-[:PRODUCED_COMPANY]-(productionCompany: ProductionCompany)
WHERE CASE WHEN NOT [] = [] THEN any(producedCompanyName in [] WHERE toLower(productionCompany.name) CONTAINS producedCompanyName) ELSE TRUE END
RETURN DISTINCT m ORDER BY m.score DESC LIMIT 10 
```
Also If I add more field such as genre, title, directorName the query works much faster. ",
          "link": "https://stackoverflow.com/q/67459833",
          "creation_date": 1620576755,
          "answer_count": 1,
          "title": "Neo4j poor order by query performance",
          "uuid": 67459833,
          "view_count": 45
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5110"
      }
    ]
  },
  {
    "t1": {
      "identity": 1682,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "cypher",
        "link": "https://stackoverflow.com/questions/tagged/cypher"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1682"
    },
    "t2": {
      "identity": 1681,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "graph",
        "link": "https://stackoverflow.com/questions/tagged/graph"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1681"
    },
    "questions": [
      {
        "identity": 4623,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 69272967,
          "body_markdown": "I want to match blogs that have most like interaction with certain tags (in the example I used dog) but posted in it less than 10 times.

How can I achieve that?

Currently, I get this error message

```
Invalid use of aggregating function count(...) in this context (line 6, column 7 (offset: 210))
&quot;WHERE COUNT(posted) &lt; 10&quot;
``` 
# Query
```
MATCH (b:Blog)-[r:liked]-(p:Post)-[:tagged]-(t:Tag)
WHERE t.content = &quot;dog&quot;
WITH b, COUNT(r) as interaction_count

MATCH (b:Blog)-[posted:posted_by]-(:Post)-[:tagged]-(t:Tag)
WHERE COUNT(posted) &lt; 10

RETURN b, interaction_count
ORDER BY interaction_count DESC
LIMIT 10
```",
          "link": "https://stackoverflow.com/q/69272255",
          "creation_date": 1632241098,
          "answer_count": 1,
          "title": "Return &#39;biggest fan of a tag&#39; neo4j",
          "uuid": 69272255,
          "view_count": 12
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4623"
      },
      {
        "identity": 206,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m building a search function in Cypher with a single input field for a graph search. The tricky part is, I don&#39;t know the labels and properties and the search query could consist of multiple words. The search should return the most relevant nodes, which can be direct-matching nodes and indirect-matching nodes, which means a node is connected to one or many direct-matching nodes. A sample search query could be: ***iphone john doe***. 

My first iteration was matching all nodes, iterating over all properties and doing a simple case-insensitive string comparison of the property value with list of search strings aka `$queries`:

    MATCH (n)
    WITH n, [k in KEYS(n) WHERE any(q IN $queries WHERE toLower(toString(n[k])) CONTAINS q) | k] AS keys
    UNWIND keys AS key
    RETURN DISTINCT n

That works quite nice, but simply returns too many matches. For my sample query, it would return all `Product` nodes which contain the word ***iPhone*** and all `Customer` nodes which contain partly the name ***John*** or ***Doe***.

What I would like to get as a result is a path of nodes with the most matches, for example:

    (p:Product {name: iPhone 11 64GB})&lt;-[:CONTAINS]-(o:Order)&lt;-[:ORDERED]-(c:Customer {firstName: John, lastName: Doe})

That means my search algo should not only consider the matches on properties of each node, but the total number of matches for a path of connected nodes. 

My first assumption is that I have break the search process down into two steps:
1. search all nodes that match on one or more properties with the search strings in the query (the more matches the higher the relevance). the result is basically a subgraph.
2. find connections betweens the nodes of the subgraph and count the number of matches of a path of connected nodes (the distance between the nodes of a path should also be a criteria for the relevance, but is not important at the moment). the result is a path of nodes.

Here&#39;s where I got stuck. Does my assumption make sense or is there another way (maybe better) to do it? Is it even possible to do it with Cypher and Neo4j (not considering the performance as a factor)?

I would be very happy about some opinions or sample queries how it could be done.",
          "link": "https://stackoverflow.com/q/64368615",
          "creation_date": 1602754188,
          "answer_count": 0,
          "title": "Search through all properties of nodes of an unknown path and return nodes with highest matching rate",
          "uuid": 64368615,
          "view_count": 18
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:206"
      },
      {
        "identity": 5121,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I want to find all the friends that posted something I liked. Why does this query return no rows but each clause by themselves returns something?

```
 match (start:Person)-[:LIKES]-&gt;(post:Post), (start)-[:FRIEND]-&gt;(person: Person), (person)-[:POSTED]-&gt;(post) return start, post, person
```
[![profile01][1]][1]
[![profile02][2]][2]


  [1]: https://i.stack.imgur.com/AQaZm.png
  [2]: https://i.stack.imgur.com/6zcAK.png",
          "link": "https://stackoverflow.com/q/67406615",
          "creation_date": 1620238223,
          "answer_count": 3,
          "title": "neo4j find all friends who posted something I liked",
          "uuid": 67406615,
          "view_count": 47
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5121"
      },
      {
        "identity": 5503,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "Say I want to find the shortest path between some node of a specific type (say &quot;central production unit&quot;) and a defined end node (say &quot;consumer&quot; with an id), how to I calculate this in Neo4j with Cypher?

With such queries i&#39;d like to answer questions like: &quot;Which production unit feeds this customer with the shortest distance&quot;.

I tried with queries like:

    match p=AllShortestPaths((source:Asset)-[:LINKS_TO*]-(destination:Asset))
    where source.type = &#39;central production unit&#39; and destination.id = &#39;1234&#39;
    return 	extract(n in nodes(p)| n.type) as type_path,
    		extract(n in nodes(p)| n.id) as id_path,
            length(p) as path_length;

queries like the one above will run into an out of memory error.

Using the same query but instead of a **type** of node, entering a specific **id** works perfectly fine. 

Sniffing around on Stackoverflow i&#39;ve found ceveral examples of 1 specific node to 1 other specific node, but not 1 yet to determine node of a certain type to 1 specific node.",
          "link": "https://stackoverflow.com/q/65978616",
          "creation_date": 1612092759,
          "answer_count": 1,
          "title": "Shortest Path between nodes of some specific type and destination node",
          "uuid": 65978616,
          "view_count": 25
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5503"
      },
      {
        "identity": 5550,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am creating a graph in Neo4j and I am starting by creating indexes. One index is linked to one csv file `Product` whose primary key is `productID`, another `Client` with `clientID` as PK and there&#39;s another file called `ShoppingCart` which contains `ProductId` and `ClientId` as PK. 

Then how can I create an index for `ShoppingCart`? Or is it not needed?

    CREATE INDEX ON :Product(productID);
    CREATE INDEX ON :Client(clientID);
    CREATE INDEX ON :ShoppingCart?????
    
Thanks!",
          "link": "https://stackoverflow.com/q/65864232",
          "creation_date": 1611435030,
          "answer_count": 1,
          "title": "How can I create in Cypher an index that involves 2 primary keys?",
          "uuid": 65864232,
          "view_count": 32
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5550"
      }
    ]
  },
  {
    "t1": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "t2": {
      "identity": 1686,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "spring-boot",
        "link": "https://stackoverflow.com/questions/tagged/spring-boot"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1686"
    },
    "questions": [
      {
        "identity": 5499,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 66005163,
          "body_markdown": "I am trying to implement a neo4j `@ConvertWith` on a list property.

    @ConvertWith(converter = &quot;SomeConverter.class&quot;) 
    List&lt;CustomObject&gt; customObject;

I see that the SomeConverter should impl -&gt;

    implements Neo4jPersistentPropertyConverter&lt;List&lt;CustomObject&gt;&gt;
but i cant get the conversion to work.. it always seems to ask for the required id property in the CustomObject

    java.lang.IllegalStateException: Required identifier property not found for class
It might not even go into my converter? 

Question: Whats the correct way to implement a converter for a list of objects?",
          "link": "https://stackoverflow.com/q/65993141",
          "creation_date": 1612184300,
          "answer_count": 1,
          "title": "Spring Data Neo4j 6 @ConvertWith implementation",
          "uuid": 65993141,
          "view_count": 157
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5499"
      },
      {
        "identity": 4965,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "Actuator health endpoint in my Spring boot application shows:

    &quot;org.neo4j.driver.exceptions.AuthenticationException: Unsupported authentication token, scheme &#39;none&#39; is only allowed when auth is disabled.&quot;

Neo4j is running, application is working properly. What may be wrong with Spring Boot Actuator?",
          "link": "https://stackoverflow.com/q/67994384",
          "creation_date": 1623797680,
          "answer_count": 0,
          "title": "Neo4j Spring Boot Actuator health and Unsupported authentication token, scheme &#39;none&#39; is only allowed when auth is disabled",
          "uuid": 67994384,
          "view_count": 24
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4965"
      },
      {
        "identity": 4832,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m getting this error when I&#39;m trying to map return values of the `query` to the `DTO`:



&gt; org.springframework.data.neo4j.core.mapping.NoRootNodeMappingException:
&gt; Could not find mappable nodes or relationships inside
&gt; Record&lt;{subjectId: 3649, subjectName: &quot;Environmental Science&quot;,
&gt; chapterId: 4574, chapterName: &quot;Growing Up&quot;}&gt; for
&gt; org.springframework.data.neo4j.core.mapping.DefaultNeo4jPersistentEntity@51543926


This is my `DTO` class:
```
@Value
public class LearnBySubjectIdResponse implements Serializable {
  
   private Long subjectId;
   private String subjectName;
   private Long  chapterId;
   private String chapterName;
   
}

  @Query(&quot;MATCH (subjectName:ContainerName)&lt;-[subject_has_name:has_name]-(subject:Container)-[subject_has_child:has_child]-(chapter:Container{cb_rack_id:1579245})-[chapter_has_name:has_name]-(chapterContainerName:ContainerName)\n&quot; +
            &quot;match (chapter)-[chapter_has_content:has_content]-&gt;(content:Content)\n&quot; +
            &quot;RETURN subjectName.rack_name_id as subjectId, subjectName.rack_name as subjectName,chapterContainerName.rack_name_id as chapterId, chapterContainerName.name as chapterName;&quot;)
    List&lt;LearnBySubjectIdResponse&gt; getChapterContent(@Param(&quot;cbRackId&quot;) long cbRackId);

```",
          "link": "https://stackoverflow.com/q/68548466",
          "creation_date": 1627402699,
          "answer_count": 0,
          "title": "org.springframework.data.neo4j.core.mapping.NoRootNodeMappingException: Could not find mappable nodes or relationships inside Record&lt;&gt;",
          "uuid": 68548466,
          "view_count": 49
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4832"
      },
      {
        "identity": 5363,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m trying to deploy a Spring boot app with Neo4j database, but when I find addons in Heroku, I can&#39;t see it. How can I do to push my Neo4j database to Heroku?
Please help me! Thank you in advance!",
          "link": "https://stackoverflow.com/q/66515511",
          "creation_date": 1615113140,
          "answer_count": 1,
          "title": "Neo4j doesn&#39;t support in Heroku?",
          "uuid": 66515511,
          "view_count": 150
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5363"
      },
      {
        "identity": 5005,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "

I&#39;m trying to run my spring boot web application with Neo4j. I&#39;m using this but can&#39;t seem to get things working.
I always get a error which begins with &quot;java.lang.IllegalStateException: Failed to execute CommandLineRunner&quot;

I am using Springboot version 2.2.2


Here is my pom.xml


```
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;accessing-data-neo4j&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;name&gt;accessing-data-neo4j&lt;/name&gt;
	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;

```
  

Here is my SpringApplicationClass:


```

@SpringBootApplication
@EnableNeo4jRepositories
public class AccessingDataNeo4jApplication {

  private final static Logger log = LoggerFactory.getLogger(AccessingDataNeo4jApplication.class);

  public static void main(String[] args) throws Exception {
    SpringApplication.run(AccessingDataNeo4jApplication.class, args);
  }

  @Bean
  CommandLineRunner demo(PersonRepository personRepository, PlaceRepository placeRepository) {
    return args -&gt; {

      // ===========================================================================================
      // == places
      // ===========================================================================================

      personRepository.deleteAll();
      placeRepository.deleteAll();

      Place goldbekmarkt = new Place(&quot;Goldbekmarkt&quot;);
      Place museum = new Place(&quot;Museum&quot;);
      Place stadtpark = new Place(&quot;Stadtpark&quot;);
      Place hagenbecksTierpark = new Place(&quot;HagenbecksTierpark&quot;);
      Place stMichaelis = new Place(&quot;St.Michaelis&quot;);

      List&lt;Place&gt; places = Arrays
          .asList(goldbekmarkt, museum, stadtpark, hagenbecksTierpark, stMichaelis);
      placeRepository.saveAll(places);

      // ===========================================================================================
      // == persons
      // ===========================================================================================

      Person orhan = new Person(&quot;Orhan&quot;);
      Person yusuf = new Person(&quot;Yusuf&quot;);
      Person steph = new Person(&quot;Steph&quot;);
      Person lebron = new Person(&quot;Lebron&quot;);
      Person kevin = new Person(&quot;Kevin&quot;);
      Person kim = new Person(&quot;Kim&quot;);
      Person tobias = new Person(&quot;Tobias&quot;);
      Person robin = new Person(&quot;Robin&quot;);
      Person niels = new Person(&quot;Niels&quot;);
      Person daniel = new Person(&quot;Daniel&quot;);
      Person michael = new Person(&quot;Michael&quot;);
      Person elia = new Person(&quot;Elia&quot;);

      List&lt;Person&gt; persons = Arrays
          .asList(orhan, yusuf, steph, lebron, kevin, kim, tobias, robin, niels, daniel, michael,
              elia);
      personRepository.saveAll(persons);

      // ===========================================================================================
      // == connect places with persons
      // ===========================================================================================

      //List&lt;WasInPlace&gt; wasInPlaces = new ArrayList();
      //wasInPlaces.add(new WasInPlace(new Date(), 20, orhan, winterhude));

      goldbekmarkt.addPlace(new WasInPlace(new Date(), 20, orhan, goldbekmarkt));
      goldbekmarkt.addPlace(new WasInPlace(new Date(), 20, robin, goldbekmarkt));
      hagenbecksTierpark.addPlace(new WasInPlace(new Date(), 20, steph, hagenbecksTierpark));
      hagenbecksTierpark.addPlace(new WasInPlace(new Date(), 20, lebron, hagenbecksTierpark));
      museum.addPlace(new WasInPlace(new Date(), 20, kevin, museum));
      museum.addPlace(new WasInPlace(new Date(), 20, yusuf, museum));
      museum.addPlace(new WasInPlace(new Date(), 20, tobias, museum));
      goldbekmarkt.addPlace(new WasInPlace(new Date(), 20, tobias, goldbekmarkt));
      stadtpark.addPlace(new WasInPlace(new Date(), 20, kim, stadtpark));
      stMichaelis.addPlace(new WasInPlace(new Date(), 20, niels, stMichaelis));
      stMichaelis.addPlace(new WasInPlace(new Date(), 20, daniel, stMichaelis));
      stMichaelis.addPlace(new WasInPlace(new Date(), 20, michael, stMichaelis));
      stMichaelis.addPlace(new WasInPlace(new Date(), 20, elia, stMichaelis));
      stadtpark.addPlace(new WasInPlace(new Date(), 20, yusuf, stadtpark));

      placeRepository.saveAll(places);

      // ===========================================================================================
      // == connect person with person
      // ===========================================================================================

      orhan.addContact(yusuf, new Date(), 10);
      orhan.addContact(steph, new Date(), 10);
      orhan.addContact(lebron, new Date(), 10);
      yusuf.addContact(kevin, new Date(), 20);
      yusuf.addContact(kim, new Date(), 20);
      steph.addContact(kim, new Date(), 10);

      personRepository.saveAll(persons);

      // ===========================================================================================
      // == tests
      // ===========================================================================================

      System.out.println();
      System.out.println(&quot;=======================================================================&quot;);
      System.out.println(&quot;== TEST&quot;);
      System.out.println(&quot;=======================================================================&quot;);
      System.out.print(yusuf.getName() + &quot;: &quot;);
      System.out
          .println(yusuf.contacts.stream().map(o -&gt;
              o.getEnd().getName()).collect(joining(&quot;,&quot;)));
    };
  }

}
```
Here is my Node:
```
@NodeEntity
public class Person {

  @Id
  @GeneratedValue
  private Long id;

  private String name;

  @Relationship(type = &quot;befand_sich_an_ort&quot;)
  private Set&lt;Place&gt; places;

  @Relationship(type = HadContactWith.TYPE, direction = Relationship.UNDIRECTED)
  public Set&lt;HadContactWith&gt; contacts = new HashSet&lt;&gt;();

  public Person(String name) {
    this.name = name;
  }

  public void addContact(Person target, Date date, int count) {
    this.contacts.add(new HadContactWith(this, target, date, count));
  }

  public Set&lt;Place&gt; getPlaces() {
    return places;
  }

  public void setPlaces(Set&lt;Place&gt; places) {
    this.places = places;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Set&lt;HadContactWith&gt; getContacts() {
    return contacts;
  }

  public void setContacts(Set&lt;HadContactWith&gt; contacts) {
    this.contacts = contacts;
  }

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }
}



```

Here is my Error:


```

Error starting ApplicationContext. To display the conditions report re-run your application with &#39;debug&#39; enabled.
2021-06-04 13:27:32.912 ERROR 6188 --- [           main] o.s.boot.SpringApplication               : Application run failed

java.lang.IllegalStateException: Failed to execute CommandLineRunner
	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:787) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:768) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:322) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at com.example.accessingdataneo4j.AccessingDataNeo4jApplication.main(AccessingDataNeo4jApplication.java:26) [main/:na]
Caused by: org.springframework.transaction.CannotCreateTransactionException: Could not open Neo4j Session for transaction; nested exception is org.neo4j.ogm.exception.ConnectionException: Could not create driver instance
	at org.springframework.data.neo4j.transaction.Neo4jTransactionManager.doBegin(Neo4jTransactionManager.java:204) ~[spring-data-neo4j-5.2.4.RELEASE.jar:5.2.4.RELEASE]
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:376) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:572) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:360) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:99) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at com.sun.proxy.$Proxy83.deleteAll(Unknown Source) ~[na:na]
	at com.example.accessingdataneo4j.AccessingDataNeo4jApplication.lambda$demo$1(AccessingDataNeo4jApplication.java:37) [main/:na]
	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:784) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	... 5 common frames omitted
Caused by: org.neo4j.ogm.exception.ConnectionException: Could not create driver instance
	at org.neo4j.ogm.drivers.bolt.driver.BoltDriver.initializeDriver(BoltDriver.java:168) ~[neo4j-ogm-bolt-driver-3.2.6.jar:3.2.6]
	at org.neo4j.ogm.drivers.bolt.driver.BoltDriver.checkDriverInitialized(BoltDriver.java:146) ~[neo4j-ogm-bolt-driver-3.2.6.jar:3.2.6]
	at org.neo4j.ogm.drivers.bolt.driver.BoltDriver.lambda$null$0(BoltDriver.java:132) ~[neo4j-ogm-bolt-driver-3.2.6.jar:3.2.6]
	at org.neo4j.ogm.session.transaction.DefaultTransactionManager.openTransaction(DefaultTransactionManager.java:75) ~[neo4j-ogm-core-3.2.6.jar:3.2.6]
	at org.neo4j.ogm.session.Neo4jSession.beginTransaction(Neo4jSession.java:541) ~[neo4j-ogm-core-3.2.6.jar:3.2.6]
	at org.springframework.data.neo4j.transaction.Neo4jTransactionManager.doBegin(Neo4jTransactionManager.java:182) ~[spring-data-neo4j-5.2.4.RELEASE.jar:5.2.4.RELEASE]
	... 18 common frames omitted
Caused by: org.neo4j.driver.exceptions.ServiceUnavailableException: Unable to connect to localhost:7687, ensure the database is running and that there is a working network connection to it.
	at org.neo4j.driver.internal.util.Futures.blockingGet(Futures.java:143) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.util.Futures.blockingGet(Futures.java:113) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.InternalDriver.verifyConnectivity(InternalDriver.java:159) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.ogm.drivers.bolt.driver.BoltDriver.initializeDriver(BoltDriver.java:165) ~[neo4j-ogm-bolt-driver-3.2.6.jar:3.2.6]
	... 23 common frames omitted
	Suppressed: org.neo4j.driver.internal.util.ErrorUtil$InternalExceptionCause: null
		at org.neo4j.driver.internal.async.connection.ChannelConnectedListener.databaseUnavailableError(ChannelConnectedListener.java:76) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.async.connection.ChannelConnectedListener.operationComplete(ChannelConnectedListener.java:70) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.async.connection.ChannelConnectedListener.operationComplete(ChannelConnectedListener.java:37) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:688) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0-262]
Caused by: org.neo4j.driver.internal.shaded.io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: localhost/127.0.0.1:7687
Caused by: java.net.ConnectException: Connection refused: no further information
	at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) ~[na:1.8.0-262]
	at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:714) ~[na:1.8.0-262]
	at org.neo4j.driver.internal.shaded.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:327) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:688) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0-262]

2021-06-04 13:27:32.918  INFO 6188 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService &#39;applicationTaskExecutor&#39;

```



Does anyone has a idea why it doesn&#39;t run?
",
          "link": "https://stackoverflow.com/q/67836894",
          "creation_date": 1622808208,
          "answer_count": 0,
          "title": "I can not connect my SpringbootApplication with Neo4j",
          "uuid": 67836894,
          "view_count": 29
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5005"
      }
    ]
  },
  {
    "t1": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "t2": {
      "identity": 1722,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "py2neo",
        "link": "https://stackoverflow.com/questions/tagged/py2neo"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1722"
    },
    "questions": [
      {
        "identity": 4736,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 68843437,
          "body_markdown": "I&#39;ve been using `neo4j` with `py2neo` for a couple of weeks now, and up to now it was fine to just do single node transactions, so I would have different node types
```python
class NodeA(GraphObject):
  ...

class NodeB(GraphObject):
  ...

# create some nodes from data and simply save them one by one
for data in dataset:
  node_a = NodeA(data)
  node_b = NodeB(data)

  if x:
    node_a.related_to_b.add(node_b)

  g.merge(node_b)
  g.merge(node_a)
```
Nothing fancy. However, I&#39;m starting to get more nodes and connections, and single transactions don&#39;t really work anymore, as expected. I&#39;ve been looking for ways to do bulk inserts, but can&#39;t find any good ressources. The best I&#39;ve managed to accomplish is using `unwind_merge_nodes_query`, which has two issues:
1. isn&#39;t that fast (~5 seconds for 700 very basic nodes on my laptop)
2. edges need to be handled separately
3. it requires keeping track of all the node ids to be able to handle edge connections

I&#39;ve been writing functions to handle the above mentioned points, but I feel like I&#39;m missing something and that there&#39;s a simpler way to handle batches of data
",
          "link": "https://stackoverflow.com/q/68833984",
          "creation_date": 1629295648,
          "answer_count": 1,
          "title": "Correct way to bulk insert / merge nodes and edges",
          "uuid": 68833984,
          "view_count": 21
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4736"
      },
      {
        "identity": 5198,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 67063748,
          "body_markdown": "**Updated question:**

I&#39;m new in neo4j and im trying to create a movie rating database. I have a file with 100.000 registers (2,3 MB) that represents when a user rated a movie; the file look like this (this dataset is from MovieLens):

[dataset file][1]

I&#39;m using py2neo and I create de datebase with this code:

``` 
data = pd.read_csv(&#39;ratings_small.csv&#39;)
def create_bipartite_graph(data):
#Indexes creation to perform the queries
    graph.run(&#39;&#39;&#39;
        CREATE INDEX user_index IF NOT EXISTS FOR (u:User) ON (u.UserId)
    &#39;&#39;&#39;)
    graph.run(&#39;&#39;&#39;
        CREATE INDEX movie_index IF NOT EXISTS FOR (m:Movie) ON (m.MovieId)
    &#39;&#39;&#39;)
    actual_user_node = None
    for index, row in data.iterrows():
        userID = int(row[&#39;userId&#39;])
        movieID = int(row[&#39;movieId&#39;])
        rating = row[&#39;rating&#39;]
        date = datetime.fromtimestamp(row[&#39;timestamp&#39;]).strftime(&quot;%m/%d/%Y, %H:%M:%S&quot;)

        #Creation nodes and relationships
        graph.run(&#39;&#39;&#39;
            MERGE(u:User{UserId: $uID})
            MERGE(m:Movie{MovieId: $mID})
            CREATE (u)-[:RATED_MOVIE{rating: $r, date: $d}]-&gt;(m)
        &#39;&#39;&#39;, parameters = {&#39;uID&#39;: userID, &#39;mID&#39;: movieID, &#39;r&#39;: rating, &#39;d&#39;: date})
```

The problem is with that small dataset, takes more than 2 hours in create the graph. Any advice for the time of the databse creation decrease considerably?

**Using ```LOAD CSV```:**

This is the query that I execute in neo4j browser
```
EXPLAIN LOAD CSV With HEADERS FROM &#39;file:///ratings_small.csv&#39; AS line FIELDTERMINATOR &#39;,&#39; 
MERGE(m:Movie{MovieId: toInteger(line.movieId)})
MERGE(u:User{UserId: toInteger(line.userId)})
CREATE (u)-[:RATED_MOVIE{rating:toFloat(line.rating)}]-&gt;(m)
```
And this is the profile plan:
[profile plan][2]


  [1]: https://i.stack.imgur.com/ORTRO.png
  [2]: https://i.stack.imgur.com/GDIzX.png",
          "link": "https://stackoverflow.com/q/67051613",
          "creation_date": 1618190546,
          "answer_count": 2,
          "title": "Database creation takes to long in neo4j",
          "uuid": 67051613,
          "view_count": 93
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5198"
      },
      {
        "identity": 5208,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;ve been trying to update an existing node using py2neo.
Some things worth metionioning:
```
OS: Arch Linux x86_64
python version: 3.8
py2neo version: 2021.0.1
ne4j version: 4.2.1
flask version: 1.1.2
Application is running inside a docker container, the actual flask website is on port 5000, neo4j interface is on port 7474 and flask connects to port 7687 (neo4j)
```


Here are a few methods I&#39;ve tried:

1)
```
def update_node(self, node_name: str, node_group: str, property_update: dict):
    return self.name_search_person(node_name=node_name, node_group=node_group).update(**property_update)
```

2)
```
def update_node(self, node_name: str, node_group: str, property_update: dict):
        node_to_update = self.name_search_person(node_name=node_name, node_group=node_group)
        if node_to_update:
            node_to_update.update(**property_update)
            self.g.push(node_to_update)
        del node_to_update
        return &#39;successfully updated node&#39;
```
At the 2nd method I&#39;ve tried with the following function calls:
```
graph_db.update_node(node_name=&#39;Andrei&#39;, node_group=&#39;Person&#39;, property_update={&#39;name&#39;: t[&#39;Updated&#39;]})
```
(this just returns NameErrror: name &#39;t&#39; is not defined (I&#39;ve seen this [Here][1])

and
```
graph_db.update_node(node_name=&#39;Andrei&#39;, node_group=&#39;Person&#39;, property_update={&#39;name&#39;:&#39;Updated&#39;})
```

Am I doing something wrong with the function calls or is the actual updating function not working by some reason?


  [1]: https://stackoverflow.com/a/64159154/10538034",
          "link": "https://stackoverflow.com/q/67021622",
          "creation_date": 1617973192,
          "title": "Py2neo updateing existing node",
          "answer_count": 1,
          "uuid": 67021622,
          "view_count": 21
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5208"
      },
      {
        "identity": 3,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am having trouble updating nodes in a neo4j-database via py2neo. I am trying to extract a network graph from several text files. My script extracts the necessary information and creates the nodes and relationships and then writes them to the database. While this works fine for some nodes, I have repeatedly run into nodes in the database that don&#39;t have all properties that should be there. 

When I run the script line by line for such a node, the information is extracted fine and the objects created in python, but the information is lost at some point during the transfer to neo4j. I execute .push() or tx.commit() which runs without error, but when I query the node in neo4j explorer, the information isn&#39;t there. The example below is for a node, but the same applies to relationships and their properties. 

I am using
 - Windows 10
 - Anaconda, version 1.10
 - Python, version 3.7.9
 - Neo4j-Desktop, version: 1.3.11
 - Neo4j-Database, version: 3.5.25
 - py2neo, version (log: 4.2.0 | pip: 2020.1.1) 


```from py2neo import Graph, Schema, Node, Relationship, walk
from py2neo.matching import *

graphdb=Graph(user=&quot;user&quot;,password=&quot;password&quot;)

def g_commit(*nds):
    graphdb=Graph(user=&quot;neo4j&quot;,password=&quot;aqnetwork2021&quot;)
    tx=graphdb.begin()
    c=0
    for n in nds:
        if &quot;py2neo.data.&quot; in str(type(n)):
            tx.create(n)
            c=c+1
    if c&gt;0:
        try:
            fdb=tx.commit()
        except Exception as e:
            if hasattr(e, &#39;message&#39;):
                fdb=e.message
            else:
                fdb=e
    else:
        fdb=&quot;No Node or Relationship Objects found&quot;
    return fdb

def checkNode(label, ident):
    check=graphdb.nodes.match(label, id=ident).first()
    if check == None:
        chckNode=Node(label,id=ident)
        chckNode.__primarylabel__=label
        chckNode.__primarykey__=&quot;id&quot;
        g_commit(chckNode)
    else:
        chckNode=check
        chckNode.__primarylabel__=label
        chckNode.__primarykey__=&quot;id&quot;
    return chckNode


pr_node=checkNode(&quot;pressrelease&quot;,id)
pr_node[&quot;date&quot;]= date #string
pr_node[&quot;heading&quot;]=heading #string
pr_node[&quot;acion&quot;]=action #string
g_commit(pr_node)
```
If I check the object in Python I get
```
dict(pr_node)
 
{&#39;id&#39;: &#39;AB/12345&#39;,
 &#39;date&#39;: &#39;02.10.2015&#39;,
 &#39;heading&#39;: &#39;Something important&#39;,
 &#39;acion&#39;: &#39;adds&#39;}
```
The log created via the logging module shows the following which I interpret as successfull
```
2021-01-12 21:10:02,474 - Adding connection pool for profile ConnectionProfile(&#39;bolt://neo4j@localhost:7687&#39;)
2021-01-12 21:10:02,474 - Trying to acquiring connection from pool &lt;ConnectionPool profile=ConnectionProfile(&#39;bolt://neo4j@localhost:7687&#39;) in_use=0 free=0 spare=100&gt;
2021-01-12 21:10:02,474 - [#0000] C: (Dialing &lt;localhost:7687&gt;)
2021-01-12 21:10:02,476 - [#F234] S: (Accepted)
2021-01-12 21:10:02,476 - [#F234] C: &lt;BOLT&gt;
2021-01-12 21:10:02,476 - [#F234] C: &lt;PROTOCOL&gt; 4.1 | 4.0 | 3.0 | 2.0
2021-01-12 21:10:02,476 - [#F234] S: &lt;PROTOCOL&gt; 3.0
2021-01-12 21:10:02,476 - [#F234] C: HELLO {&#39;user_agent&#39;: &#39;py2neo/4.2.0 Python/3.7.9-final-0 (win32)&#39;, &#39;scheme&#39;: &#39;basic&#39;, &#39;principal&#39;: &#39;neo4j&#39;, &#39;credentials&#39;: &#39;*******&#39;}
2021-01-12 21:10:02,476 - [#F234] C: (Sent 116 bytes)
2021-01-12 21:10:02,477 - [#F234] S: SUCCESS {&#39;server&#39;: &#39;Neo4j/3.5.25&#39;, &#39;connection_id&#39;: &#39;bolt-83&#39;}
2021-01-12 21:10:02,477 - Acquired connection &lt;py2neo.client.bolt.Bolt3 object at 0x0000017DBFC93D88&gt;
2021-01-12 21:10:02,477 - Releasing connection &lt;py2neo.client.bolt.Bolt3 object at 0x0000017DBFC93D88&gt;
2021-01-12 21:10:02,477 - Attempting to acquire connection to default database
2021-01-12 21:10:02,477 - Using connection pool &lt;ConnectionPool profile=ConnectionProfile(&#39;bolt://neo4j@localhost:7687&#39;) in_use=0 free=1 spare=99&gt;
2021-01-12 21:10:02,477 - Trying to acquiring connection from pool &lt;ConnectionPool profile=ConnectionProfile(&#39;bolt://neo4j@localhost:7687&#39;) in_use=0 free=1 spare=99&gt;
2021-01-12 21:10:02,477 - Acquired connection &lt;py2neo.client.bolt.Bolt3 object at 0x0000017DBFC93D88&gt;
2021-01-12 21:10:02,477 - [#F234] C: BEGIN {}
2021-01-12 21:10:02,478 - [#F234] C: (Sent 7 bytes)
2021-01-12 21:10:02,478 - [#F234] S: SUCCESS {}
2021-01-12 21:10:02,478 - [#F234] C: COMMIT
2021-01-12 21:10:02,478 - [#F234] C: (Sent 6 bytes)
2021-01-12 21:10:02,479 - [#F234] S: SUCCESS {&#39;bookmark&#39;: &#39;neo4j:bookmark:v1:tx49427&#39;}
2021-01-12 21:10:02,479 - Releasing connection &lt;py2neo.client.bolt.Bolt3 object at 0x0000017DBFC93D88&gt;
```
I check the object in neo4j however I get
```
MATCH(n:pressrelease) WHERE (n.id=&quot;AB/12345&quot;) RETURN n

{
  &quot;identity&quot;: 9770,
  &quot;labels&quot;: [
    &quot;pressrelease&quot;
  ],
  &quot;properties&quot;: {
&quot;id&quot;: &quot;SC/12067&quot;
  }
}
```
Sometimes, when I use graphdb.push() instead this works, but not reliably.

Am I missing something in my code? I am somewhat lost as to where to look for the error.",
          "link": "https://stackoverflow.com/q/65691774",
          "creation_date": 1610484214,
          "answer_count": 0,
          "title": "py2neo doesn&#39;t update database nodes",
          "uuid": 65691774,
          "view_count": 94
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:3"
      },
      {
        "identity": 5291,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I was following simple py2neo tutorial here: http://nicolewhite.github.io/neo4j-jupyter/hello-world.html

Everything worked fine, all the entries appear in the neo4j in-browser version, however when I try to run inline Cypher queries, I get a 404 error.

```
%%cypher
http://neo4j:password@localhost:7474/db/data/
MATCH (person:Person)-[:LIKES]-&gt;(drink:Drink)
RETURN person.name, drink.name, drink.calories
```
Here&#39;s the traceback: 
```
Format: (http|https)://username:password@hostname:port/db/name
---------------------------------------------------------------------------
NotFoundError                             Traceback (most recent call last)
&lt;ipython-input-12-de2d5705ff61&gt; in &lt;module&gt;
----&gt; 1 get_ipython().run_cell_magic(&#39;cypher&#39;, &#39;&#39;, &#39;http://neo4j:password@localhost:7474/db/data/\nMATCH (person:Person)-[:LIKES]-&gt;(drink:Drink)\nRETURN person.name, drink.name, drink.calories\n&#39;)

~/.local/lib/python3.6/site-packages/IPython/core/interactiveshell.py in run_cell_magic(self, magic_name, line, cell)
   2369             with self.builtin_trap:
   2370                 args = (magic_arg_s, cell)
-&gt; 2371                 result = fn(*args, **kwargs)
   2372             return result
   2373 

&lt;decorator-gen-127&gt; in execute(self, line, cell, local_ns)

~/.local/lib/python3.6/site-packages/IPython/core/magic.py in &lt;lambda&gt;(f, *a, **k)
    185     # but it&#39;s overkill for just that one bit of state.
    186     def magic_deco(arg):
--&gt; 187         call = lambda f, *a, **k: f(*a, **k)
    188 
    189         if callable(arg):

&lt;decorator-gen-126&gt; in execute(self, line, cell, local_ns)

~/.local/lib/python3.6/site-packages/IPython/core/magic.py in &lt;lambda&gt;(f, *a, **k)
    185     # but it&#39;s overkill for just that one bit of state.
    186     def magic_deco(arg):
--&gt; 187         call = lambda f, *a, **k: f(*a, **k)
    188 
    189         if callable(arg):

~/.local/lib/python3.6/site-packages/cypher/magic.py in execute(self, line, cell, local_ns)
    106         user_ns.update(local_ns)
    107         parsed = parse(&quot;&quot;&quot;{0}\n{1}&quot;&quot;&quot;.format(line, cell), self)
--&gt; 108         conn = Connection.get(parsed[&#39;as&#39;] or parsed[&#39;uri&#39;], parsed[&#39;as&#39;])
    109         first_word = parsed[&#39;cypher&#39;].split(None, 1)[:1]
    110         if first_word and first_word[0].lower() == &#39;persist&#39;:

~/.local/lib/python3.6/site-packages/cypher/connection.py in get(cls, descriptor, alias)
     45                 cls.current = conn
     46             else:
---&gt; 47                 cls.current = Connection(descriptor, alias)
     48         if cls.current:
     49             return cls.current

~/.local/lib/python3.6/site-packages/cypher/connection.py in __init__(self, connect_str, alias)
     24                 gdb = GraphDatabase(self.connections[connect_str])
     25             else:
---&gt; 26                 gdb = GraphDatabase(connect_str)
     27                 alias = alias or connect_str
     28         except:

~/.local/lib/python3.6/site-packages/neo4jrestclient/client.py in __init__(self, url, username, password, cert_file, key_file)
     81             response_json = response.json()
     82         else:
---&gt; 83             raise NotFoundError(response.status_code, &quot;Unable get root&quot;)
     84         if &quot;data&quot; in response_json and &quot;management&quot; in response_json:
     85             response = Request(**self._auth).get(response_json[&quot;data&quot;])

NotFoundError: Code [404]: Not Found. Nothing matches the given URI.
Unable get root

```

I tried checking if the URI works according to this answer [here](https://stackoverflow.com/questions/33260980/neo4j-rest-api-is-returning-404), and I get 404 error there too:

```
~$ curl -i --user neo4j:password http://localhost:7474/db/data/
HTTP/1.1 404 Not Found
Access-Control-Allow-Origin: *
Cache-Control: must-revalidate,no-cache,no-store
Content-Type: text/html;charset=iso-8859-1
Content-Length: 0
```

I tried setting the `Graph` option to include the link, but it didn&#39;t help:

```
graph = Graph(&quot;http://neo4j:password@localhost:7474/db/data/&quot;)
```

Could you please tell me where have I made a mistake?",
          "link": "https://stackoverflow.com/q/66741099",
          "creation_date": 1616393628,
          "answer_count": 1,
          "title": "py2neo: using cypher inline gives 404 error",
          "uuid": 66741099,
          "view_count": 27
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5291"
      }
    ]
  },
  {
    "t1": {
      "identity": 1682,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "cypher",
        "link": "https://stackoverflow.com/questions/tagged/cypher"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1682"
    },
    "t2": {
      "identity": 1699,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "python",
        "link": "https://stackoverflow.com/questions/tagged/python"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1699"
    },
    "questions": [
      {
        "identity": 5196,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am trying to pass on the parameter to the cypher query in a function but it is not returning the results as expected. First error was `ClientError: {code: Neo.ClientError.Statement.ParameterMissing} {message: Expected parameter(s): x}` I checked it on another forum where I also had to pass the parameter along with query run session I did so and error disappeared but still it didn&#39;t get the results as expected and returned the empty nodes. 

In the graph db the nodes are connected with 4 types of relationships with an ids. 

This is what I have tried so far: 

    def get_objects(x):
        query = &#39;&#39;&#39; MATCH (p)-[r]-&gt;(a) where r.id = $x RETURN p.id; &#39;&#39;&#39; 
        resultNodes = session.run(query, x = x)
        df = DataFrame(resultNodes)
        print(df)
        return df
    
    def find_max_1():
        authors,terms,venues,papers=0,0,0,0
        authors=get_objects(1).max()
        terms=get_objects(2).max()
        venues=get_objects(3).max()
        papers=get_objects(4).max()
        return authors,terms,venues,papers
    
    def main():
        
        m = m=find_max_1()
        
    
    if __name__ == &quot;__main__&quot;:
        
        main()
and the output is: 

    Empty DataFrame
    Columns: []
    Index: []
    Empty DataFrame
    Columns: []
    Index: []
    Empty DataFrame
    Columns: []
    Index: []
    Empty DataFrame
    Columns: []
    Index: []

I am unable to identify what&#39;s wrong with this.

Any kind of help in right direction would be appreciated. 

Thanks in advance. ",
          "link": "https://stackoverflow.com/q/67055300",
          "creation_date": 1618217123,
          "answer_count": 2,
          "title": "Neo4j cypher query doesn&#39;t return the results as expected into pandas DataFrame",
          "uuid": 67055300,
          "view_count": 49
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5196"
      },
      {
        "identity": 110,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m doing this exercise from computer science circle. Here&#39;s the information:

&gt; Write a program which does the following. First, it should read one line of input, which is the encoded message, and will consist of capital letters and spaces. 
Your program must try decoding the message with all 26 possible values of the shift S; out of these 26 possible original messages, print the one which has the highest goodness.
For your convenience, we will pre-define the variable letterGoodness for you, a list of length 26 which equals the values in the frequency table above,
letterGoodness = [.0817,.0149,.0278,.0425,.1270,.0223,.0202,...

I&#39;ve done some coding but it kept saying &#39;list index out of range&#39; at line 24 (the letterGoodness[diff] line). I checked but couldn&#39;t find out why.

Here&#39;s the code:

```
#subtask 1: shifting values
a = input ()
def Decode(S):
   b = &quot;&quot;
   for i in range (0, len (a)):
      if a[i] != &quot; &quot;:
         if ord(a[i]) + int(S) &lt;= 90:
            c = chr(ord(a[i]) + int(S))
            b = b + c
         else:
            c = chr(ord(a[i]) + int(S) - 65)
            b = b + c
      else:
         b = b + a[i]
   return b
#subtask 2: determining goodness
goodness = 0
maxx = 0
for S in range (1, 27):
   b = Decode (S)
   for ii in range (0, len(b)):
      if b[ii] != &quot; &quot;: 
         diff = (ord(b[ii]) - 65)
         goodness = goodness + letterGoodness[diff]
         if goodness &gt; maxx:
            maxx = goodness
            out = b

print (out)
```
Thanks for reading this and helping me!! I really appreciate it :))",
          "link": "https://stackoverflow.com/q/65130450",
          "creation_date": 1607014387,
          "answer_count": 0,
          "title": "Auto-Decryption Question from Computer Science Circles (Python)",
          "uuid": 65130450,
          "view_count": 55
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:110"
      },
      {
        "identity": 301,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have a dict and a cypher query with placeholders. My code currently works:

    def set_dict(self, tx, my_dict):
        for i, j in my_dict.items():
            tx.run(&quot;MERGE (n:property_1 {i: $i})
            SET n.j = $j; &quot;,
            i=i, j=j)


This works, but rather than looping through and executing `tx.run`, is there a more pythonic/faster was of executing a dict as a placeholder in a CQL string?

",
          "link": "https://stackoverflow.com/q/63691017",
          "creation_date": 1598974845,
          "answer_count": 1,
          "title": "Quicker way to write a dict to a neo4j database using python",
          "uuid": 63691017,
          "view_count": 50
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:301"
      },
      {
        "identity": 4639,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 69203303,
          "body_markdown": "I have a list of dictionaries I have created in python. It looks like this:
```
[{name: &#39;Bob&#39;}, {name: &#39;Teresa&#39;}, {name: &#39;Bob&#39;}, {name: &#39;Teresa&#39;}]
```

Here&#39;s my cypher query to take this list and merge into Neo4j that I&#39;m expecting only 2 new nodes are created, Bob and Teresa nodes.

```
WITH $batch AS batch
UNWIND batch as ind
MERGE (n:Friend)
SET n += ind
```

What I&#39;m seeing is that I only see 1 node that&#39;s written to Neo4j and it seems like it&#39;s whatever the last item in the list. In this example, Teresa node is the only one that got created.

How should I fix my query so that I see Bob AND Teresa nodes created once it finishes running? Is it better practice to make the list unique `[{name: &#39;Bob&#39;}, {name: &#39;Teresa&#39;}]` and use `CREATE` instead of `MERGE` instead?",
          "link": "https://stackoverflow.com/q/69200606",
          "creation_date": 1631746686,
          "title": "MERGE with UNWIND Issue Neo4j",
          "answer_count": 1,
          "uuid": 69200606,
          "view_count": 24
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4639"
      },
      {
        "identity": 313,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 63622414,
          "body_markdown": "I have a list of words that I want to use as seed labels in Neo4j. 

These labels are renewed everyday so I would like to automate my Cypher requests.

Here is the list I have today:

List : `list_of_labels = [&#39;crise sanitaire&#39;, &#39;face crise&#39;, &#39;confinement avril&#39;, &#39;crise coronavirus&#39;, &#39;virus guerre&#39;]`

I tried this with variables in my Cypher requests:

`def create_seed_property(tx, i):    j = 0    while j &lt; len(list_of_labels): tx.run(&quot; MATCH (n:ARTICLE  {label: $i}) SET n.seed_label = $j RETURN n &quot;)    j +=1`

And next I did this:

`for i in list_of_labels: session.read_transaction(create_seed_property(i))`

I don&#39;t know where I&#39;m wrong.

[ADDENDUM]

I would like to add `seed_label` = 0 for &#39;crise sanitaire&#39;, `seed_label` = 1 for &#39;face crise&#39; etc. I want to add `seed_label` property for each string in the list_of_labels list. But the list is renewed every day, that&#39;s why I try to automate it.",
          "link": "https://stackoverflow.com/q/63617909",
          "creation_date": 1598537474,
          "answer_count": 1,
          "title": "Cypher &amp; Neo4j : for loop with Cypher request",
          "uuid": 63617909,
          "view_count": 44
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:313"
      }
    ]
  },
  {
    "t1": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "t2": {
      "identity": 1717,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "spring",
        "link": "https://stackoverflow.com/questions/tagged/spring"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1717"
    },
    "questions": [
      {
        "identity": 4832,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m getting this error when I&#39;m trying to map return values of the `query` to the `DTO`:



&gt; org.springframework.data.neo4j.core.mapping.NoRootNodeMappingException:
&gt; Could not find mappable nodes or relationships inside
&gt; Record&lt;{subjectId: 3649, subjectName: &quot;Environmental Science&quot;,
&gt; chapterId: 4574, chapterName: &quot;Growing Up&quot;}&gt; for
&gt; org.springframework.data.neo4j.core.mapping.DefaultNeo4jPersistentEntity@51543926


This is my `DTO` class:
```
@Value
public class LearnBySubjectIdResponse implements Serializable {
  
   private Long subjectId;
   private String subjectName;
   private Long  chapterId;
   private String chapterName;
   
}

  @Query(&quot;MATCH (subjectName:ContainerName)&lt;-[subject_has_name:has_name]-(subject:Container)-[subject_has_child:has_child]-(chapter:Container{cb_rack_id:1579245})-[chapter_has_name:has_name]-(chapterContainerName:ContainerName)\n&quot; +
            &quot;match (chapter)-[chapter_has_content:has_content]-&gt;(content:Content)\n&quot; +
            &quot;RETURN subjectName.rack_name_id as subjectId, subjectName.rack_name as subjectName,chapterContainerName.rack_name_id as chapterId, chapterContainerName.name as chapterName;&quot;)
    List&lt;LearnBySubjectIdResponse&gt; getChapterContent(@Param(&quot;cbRackId&quot;) long cbRackId);

```",
          "link": "https://stackoverflow.com/q/68548466",
          "creation_date": 1627402699,
          "answer_count": 0,
          "title": "org.springframework.data.neo4j.core.mapping.NoRootNodeMappingException: Could not find mappable nodes or relationships inside Record&lt;&gt;",
          "uuid": 68548466,
          "view_count": 49
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4832"
      },
      {
        "identity": 5363,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m trying to deploy a Spring boot app with Neo4j database, but when I find addons in Heroku, I can&#39;t see it. How can I do to push my Neo4j database to Heroku?
Please help me! Thank you in advance!",
          "link": "https://stackoverflow.com/q/66515511",
          "creation_date": 1615113140,
          "answer_count": 1,
          "title": "Neo4j doesn&#39;t support in Heroku?",
          "uuid": 66515511,
          "view_count": 150
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5363"
      },
      {
        "identity": 5005,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "

I&#39;m trying to run my spring boot web application with Neo4j. I&#39;m using this but can&#39;t seem to get things working.
I always get a error which begins with &quot;java.lang.IllegalStateException: Failed to execute CommandLineRunner&quot;

I am using Springboot version 2.2.2


Here is my pom.xml


```
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;accessing-data-neo4j&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;name&gt;accessing-data-neo4j&lt;/name&gt;
	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;

```
  

Here is my SpringApplicationClass:


```

@SpringBootApplication
@EnableNeo4jRepositories
public class AccessingDataNeo4jApplication {

  private final static Logger log = LoggerFactory.getLogger(AccessingDataNeo4jApplication.class);

  public static void main(String[] args) throws Exception {
    SpringApplication.run(AccessingDataNeo4jApplication.class, args);
  }

  @Bean
  CommandLineRunner demo(PersonRepository personRepository, PlaceRepository placeRepository) {
    return args -&gt; {

      // ===========================================================================================
      // == places
      // ===========================================================================================

      personRepository.deleteAll();
      placeRepository.deleteAll();

      Place goldbekmarkt = new Place(&quot;Goldbekmarkt&quot;);
      Place museum = new Place(&quot;Museum&quot;);
      Place stadtpark = new Place(&quot;Stadtpark&quot;);
      Place hagenbecksTierpark = new Place(&quot;HagenbecksTierpark&quot;);
      Place stMichaelis = new Place(&quot;St.Michaelis&quot;);

      List&lt;Place&gt; places = Arrays
          .asList(goldbekmarkt, museum, stadtpark, hagenbecksTierpark, stMichaelis);
      placeRepository.saveAll(places);

      // ===========================================================================================
      // == persons
      // ===========================================================================================

      Person orhan = new Person(&quot;Orhan&quot;);
      Person yusuf = new Person(&quot;Yusuf&quot;);
      Person steph = new Person(&quot;Steph&quot;);
      Person lebron = new Person(&quot;Lebron&quot;);
      Person kevin = new Person(&quot;Kevin&quot;);
      Person kim = new Person(&quot;Kim&quot;);
      Person tobias = new Person(&quot;Tobias&quot;);
      Person robin = new Person(&quot;Robin&quot;);
      Person niels = new Person(&quot;Niels&quot;);
      Person daniel = new Person(&quot;Daniel&quot;);
      Person michael = new Person(&quot;Michael&quot;);
      Person elia = new Person(&quot;Elia&quot;);

      List&lt;Person&gt; persons = Arrays
          .asList(orhan, yusuf, steph, lebron, kevin, kim, tobias, robin, niels, daniel, michael,
              elia);
      personRepository.saveAll(persons);

      // ===========================================================================================
      // == connect places with persons
      // ===========================================================================================

      //List&lt;WasInPlace&gt; wasInPlaces = new ArrayList();
      //wasInPlaces.add(new WasInPlace(new Date(), 20, orhan, winterhude));

      goldbekmarkt.addPlace(new WasInPlace(new Date(), 20, orhan, goldbekmarkt));
      goldbekmarkt.addPlace(new WasInPlace(new Date(), 20, robin, goldbekmarkt));
      hagenbecksTierpark.addPlace(new WasInPlace(new Date(), 20, steph, hagenbecksTierpark));
      hagenbecksTierpark.addPlace(new WasInPlace(new Date(), 20, lebron, hagenbecksTierpark));
      museum.addPlace(new WasInPlace(new Date(), 20, kevin, museum));
      museum.addPlace(new WasInPlace(new Date(), 20, yusuf, museum));
      museum.addPlace(new WasInPlace(new Date(), 20, tobias, museum));
      goldbekmarkt.addPlace(new WasInPlace(new Date(), 20, tobias, goldbekmarkt));
      stadtpark.addPlace(new WasInPlace(new Date(), 20, kim, stadtpark));
      stMichaelis.addPlace(new WasInPlace(new Date(), 20, niels, stMichaelis));
      stMichaelis.addPlace(new WasInPlace(new Date(), 20, daniel, stMichaelis));
      stMichaelis.addPlace(new WasInPlace(new Date(), 20, michael, stMichaelis));
      stMichaelis.addPlace(new WasInPlace(new Date(), 20, elia, stMichaelis));
      stadtpark.addPlace(new WasInPlace(new Date(), 20, yusuf, stadtpark));

      placeRepository.saveAll(places);

      // ===========================================================================================
      // == connect person with person
      // ===========================================================================================

      orhan.addContact(yusuf, new Date(), 10);
      orhan.addContact(steph, new Date(), 10);
      orhan.addContact(lebron, new Date(), 10);
      yusuf.addContact(kevin, new Date(), 20);
      yusuf.addContact(kim, new Date(), 20);
      steph.addContact(kim, new Date(), 10);

      personRepository.saveAll(persons);

      // ===========================================================================================
      // == tests
      // ===========================================================================================

      System.out.println();
      System.out.println(&quot;=======================================================================&quot;);
      System.out.println(&quot;== TEST&quot;);
      System.out.println(&quot;=======================================================================&quot;);
      System.out.print(yusuf.getName() + &quot;: &quot;);
      System.out
          .println(yusuf.contacts.stream().map(o -&gt;
              o.getEnd().getName()).collect(joining(&quot;,&quot;)));
    };
  }

}
```
Here is my Node:
```
@NodeEntity
public class Person {

  @Id
  @GeneratedValue
  private Long id;

  private String name;

  @Relationship(type = &quot;befand_sich_an_ort&quot;)
  private Set&lt;Place&gt; places;

  @Relationship(type = HadContactWith.TYPE, direction = Relationship.UNDIRECTED)
  public Set&lt;HadContactWith&gt; contacts = new HashSet&lt;&gt;();

  public Person(String name) {
    this.name = name;
  }

  public void addContact(Person target, Date date, int count) {
    this.contacts.add(new HadContactWith(this, target, date, count));
  }

  public Set&lt;Place&gt; getPlaces() {
    return places;
  }

  public void setPlaces(Set&lt;Place&gt; places) {
    this.places = places;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Set&lt;HadContactWith&gt; getContacts() {
    return contacts;
  }

  public void setContacts(Set&lt;HadContactWith&gt; contacts) {
    this.contacts = contacts;
  }

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }
}



```

Here is my Error:


```

Error starting ApplicationContext. To display the conditions report re-run your application with &#39;debug&#39; enabled.
2021-06-04 13:27:32.912 ERROR 6188 --- [           main] o.s.boot.SpringApplication               : Application run failed

java.lang.IllegalStateException: Failed to execute CommandLineRunner
	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:787) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:768) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:322) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	at com.example.accessingdataneo4j.AccessingDataNeo4jApplication.main(AccessingDataNeo4jApplication.java:26) [main/:na]
Caused by: org.springframework.transaction.CannotCreateTransactionException: Could not open Neo4j Session for transaction; nested exception is org.neo4j.ogm.exception.ConnectionException: Could not create driver instance
	at org.springframework.data.neo4j.transaction.Neo4jTransactionManager.doBegin(Neo4jTransactionManager.java:204) ~[spring-data-neo4j-5.2.4.RELEASE.jar:5.2.4.RELEASE]
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:376) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:572) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:360) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:99) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139) ~[spring-tx-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) ~[spring-aop-5.2.3.RELEASE.jar:5.2.3.RELEASE]
	at com.sun.proxy.$Proxy83.deleteAll(Unknown Source) ~[na:na]
	at com.example.accessingdataneo4j.AccessingDataNeo4jApplication.lambda$demo$1(AccessingDataNeo4jApplication.java:37) [main/:na]
	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:784) [spring-boot-2.2.4.RELEASE.jar:2.2.4.RELEASE]
	... 5 common frames omitted
Caused by: org.neo4j.ogm.exception.ConnectionException: Could not create driver instance
	at org.neo4j.ogm.drivers.bolt.driver.BoltDriver.initializeDriver(BoltDriver.java:168) ~[neo4j-ogm-bolt-driver-3.2.6.jar:3.2.6]
	at org.neo4j.ogm.drivers.bolt.driver.BoltDriver.checkDriverInitialized(BoltDriver.java:146) ~[neo4j-ogm-bolt-driver-3.2.6.jar:3.2.6]
	at org.neo4j.ogm.drivers.bolt.driver.BoltDriver.lambda$null$0(BoltDriver.java:132) ~[neo4j-ogm-bolt-driver-3.2.6.jar:3.2.6]
	at org.neo4j.ogm.session.transaction.DefaultTransactionManager.openTransaction(DefaultTransactionManager.java:75) ~[neo4j-ogm-core-3.2.6.jar:3.2.6]
	at org.neo4j.ogm.session.Neo4jSession.beginTransaction(Neo4jSession.java:541) ~[neo4j-ogm-core-3.2.6.jar:3.2.6]
	at org.springframework.data.neo4j.transaction.Neo4jTransactionManager.doBegin(Neo4jTransactionManager.java:182) ~[spring-data-neo4j-5.2.4.RELEASE.jar:5.2.4.RELEASE]
	... 18 common frames omitted
Caused by: org.neo4j.driver.exceptions.ServiceUnavailableException: Unable to connect to localhost:7687, ensure the database is running and that there is a working network connection to it.
	at org.neo4j.driver.internal.util.Futures.blockingGet(Futures.java:143) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.util.Futures.blockingGet(Futures.java:113) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.InternalDriver.verifyConnectivity(InternalDriver.java:159) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.ogm.drivers.bolt.driver.BoltDriver.initializeDriver(BoltDriver.java:165) ~[neo4j-ogm-bolt-driver-3.2.6.jar:3.2.6]
	... 23 common frames omitted
	Suppressed: org.neo4j.driver.internal.util.ErrorUtil$InternalExceptionCause: null
		at org.neo4j.driver.internal.async.connection.ChannelConnectedListener.databaseUnavailableError(ChannelConnectedListener.java:76) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.async.connection.ChannelConnectedListener.operationComplete(ChannelConnectedListener.java:70) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.async.connection.ChannelConnectedListener.operationComplete(ChannelConnectedListener.java:37) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:688) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
		at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0-262]
Caused by: org.neo4j.driver.internal.shaded.io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: localhost/127.0.0.1:7687
Caused by: java.net.ConnectException: Connection refused: no further information
	at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) ~[na:1.8.0-262]
	at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:714) ~[na:1.8.0-262]
	at org.neo4j.driver.internal.shaded.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:327) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:688) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at org.neo4j.driver.internal.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[neo4j-java-driver-4.0.0.jar:4.0.0-d03d93ede8ad65657eeb90ed890757203ecfaa7a]
	at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0-262]

2021-06-04 13:27:32.918  INFO 6188 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService &#39;applicationTaskExecutor&#39;

```



Does anyone has a idea why it doesn&#39;t run?
",
          "link": "https://stackoverflow.com/q/67836894",
          "creation_date": 1622808208,
          "answer_count": 0,
          "title": "I can not connect my SpringbootApplication with Neo4j",
          "uuid": 67836894,
          "view_count": 29
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5005"
      },
      {
        "identity": 529,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m trying to send data from Neo4J to Spring boot and I want to receive a JSON like this:
```
{
  &quot;name&quot;: &quot;Alex Statham&quot;,
  &quot;people&quot;: [
    {
      &quot;name&quot;: &quot;Jason Statham&quot;,
      &quot;people&quot;: [
        {
          &quot;name&quot;: &quot;Lyna Statham&quot;
        },
        {
          &quot;name&quot;: &quot;John Statham&quot;
        }
      ]
    },
    {
      &quot;name&quot;: &quot;Will Statham&quot;,
      &quot;people&quot;: [
        {
          &quot;name&quot;: &quot;Michael Statham&quot;
        }
      ]
    }
  ]
}
```
I try many query and this one maybe the best query which returns a correct family tree for all cases, but it only return nodes with no relationship so I can&#39;t put that data to the Library I use:
```
MATCH (p1:Person {maBN:3})
CALL apoc.path.subgraphNodes(p1, {
    sequence: &#39;&gt;Person,FCHILD,&gt;Person,FCHILD,&gt;Person&#39;,
    maxLevel: 6
}) YIELD node
RETURN node, p1
```

Here is that Library: https://www.npmjs.com/package/react-tree-graph

What should I do? I don&#39;t know too much about Cypher and Neo4j.",
          "link": "https://stackoverflow.com/q/61906725",
          "creation_date": 1589957099,
          "answer_count": 1,
          "title": "Receive JSON data from Neo4j to Spring Boot API",
          "uuid": 61906725,
          "view_count": 67
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:529"
      },
      {
        "identity": 5300,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am new to Java and spring framework. I am working on a neo4j project where I have neo4j image with docker. My main goal is to create a company node and link other nodes to it using neo4j and spring boot.

So far, I didn&#39;t make much progress. I can only create a project resource at the endpoint api/company/line/projects.

like this:

[![enter image description here][1]][1]


Here&#39;s the catch. I want to go to endpoint api/company/line/projects/employees and send a GET request here and get Employees that are in this project. But at this moment it is very confusing to me and I don&#39;t know how to do this.

Any help is appreciated

Here are my classes:

[![enter image description here][2]][2]


  [1]: https://i.stack.imgur.com/c8rsk.png
  [2]: https://i.stack.imgur.com/hOihV.png

Employee class:
```
package com.thebman.neo4jstudy.node;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.neo4j.ogm.annotation.GraphId;
import org.neo4j.ogm.annotation.NodeEntity;
import org.springframework.data.neo4j.core.schema.GeneratedValue;
import org.springframework.data.neo4j.core.schema.Id;
import org.springframework.data.neo4j.core.schema.Node;
import org.springframework.data.neo4j.core.schema.Relationship;

@Data
@AllArgsConstructor
@NoArgsConstructor
@NodeEntity
public class Employee {
    @Id
    @GeneratedValue
    private Long Id;
    private String name;
    private int age;

}
```
Project class:
```
package com.thebman.neo4jstudy.node;

import com.sun.istack.internal.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.neo4j.ogm.annotation.NodeEntity;
import org.springframework.data.neo4j.core.schema.GeneratedValue;
import org.springframework.data.neo4j.core.schema.Id;
import org.springframework.data.neo4j.core.schema.Relationship;

import java.util.Set;

@Data
@AllArgsConstructor
@NoArgsConstructor
@NodeEntity
public class Project {
    @Id
    @GeneratedValue
    private Long entityId;
    private String name;
    private String location;

    @Relationship(type = &quot;works_for&quot;, direction = Relationship.Direction.INCOMING)
    private Set&lt;Employee&gt; employee;

}
```

and controller class:
```
package com.thebman.neo4jstudy.controller;

import com.thebman.neo4jstudy.node.Line;
import com.thebman.neo4jstudy.node.Project;
import com.thebman.neo4jstudy.node.Employee;
import com.thebman.neo4jstudy.service.LineService;
import com.thebman.neo4jstudy.service.ProjectService;
import com.thebman.neo4jstudy.service.PersonService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(value = &quot;/api/company&quot;)
public class CompanyController {
    @Autowired
    private ProjectService projectService;

    @Autowired
    private PersonService personService;

    @Autowired
    private LineService lineService;


    @PostMapping(&quot;/line/projects&quot;)
    ResponseEntity saveProject(@RequestBody Project project) {
        return new ResponseEntity(projectService.saveProject(project), HttpStatus.CREATED);
    }

    @GetMapping(&quot;/line/projects&quot;)
    ResponseEntity getProjects() {
        return new ResponseEntity(projectService.getProjects(), HttpStatus.OK);
    }

    @DeleteMapping(&quot;/line/projects/{project_name}&quot;)
    ResponseEntity deleteProject(@PathVariable String project_name) {
        projectService.deleteProject(project_name);
        return new ResponseEntity(HttpStatus.OK);
    }

    @GetMapping(&quot;/line/projects/{project_name}/employee&quot;)
    ResponseEntity getEmployee(@PathVariable String project_name) {

        return new ResponseEntity(projectService.getEmployee(project_name), HttpStatus.CREATED);
    }

    @PostMapping(&quot;/line/projects/{project_name}/employee&quot;)
    ResponseEntity saveEmployee(@RequestBody Employee employee) {

        return new ResponseEntity(personService.savePerson(employee), HttpStatus.CREATED);
    }

    @PostMapping(&quot;/line&quot;)
    ResponseEntity saveLine(@RequestBody Line line) {
        return new ResponseEntity( lineService.saveLine(line), HttpStatus.CREATED);
    }
}
```
",
          "link": "https://stackoverflow.com/q/66695863",
          "creation_date": 1616087506,
          "answer_count": 0,
          "title": "How can I map one class to another in spring boot w/ neo4j?",
          "uuid": 66695863,
          "view_count": 29
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5300"
      }
    ]
  },
  {
    "t1": {
      "identity": 1679,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "neo4j",
        "link": "https://stackoverflow.com/questions/tagged/neo4j"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1679"
    },
    "t2": {
      "identity": 1751,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "node.js",
        "link": "https://stackoverflow.com/questions/tagged/node.js"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1751"
    },
    "questions": [
      {
        "identity": 325,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have my community 4.1.1 neo4j service installed on the ubuntu commandline running on my windows machine. I have been using neo4j steadily for a month or two now, just recently it has prevented me from accessing the neo4j database, it will say this in neo4j browser:

`Database &#39;neo4j&#39; is unavailable. Run :sysinfo for more info.`

I have tried uninstalling neo4j and reinstalling but that has not worked either. I tried playing around with the default listen address previously, but now with the reinstall all config data is back to normal. Running ./neo4j-community-4.1.1/bin/cypher-shell under bin does not work. It says:

`Unable to establish connection in 3000ms`

If I run ./neo4j-community-4.1.1/bin/cypher-shell -a 192.168.0.19 it says:

`Database &#39;neo4j&#39; is unavailable`

When I run ./neo4j-community-4.1.1/bin/neo4j-admin check-consistency --database=neo4j it also states:

`.2020-08-18 22:12:16.868+0000 WARN [o.n.c.ConsistencyCheckService] Index was dirty on startup which means it was not shutdown correctly and need to be cleaned up with a successful recovery.
        Index file: /home/thomp105/neo4j-community-4.1.1/data/databases/neo4j/neostore.relationshipgroupstore.db.id.`

I would love to reset everything from scratch but I am unsure how
At this point I cannot even access the browser at localhost:7474. It hangs indefinitely trying to load.

I am truly stumped. Anyone have any advice on how I navigate this issue?
",
          "link": "https://stackoverflow.com/q/63477398",
          "creation_date": 1597789138,
          "answer_count": 2,
          "title": "Database &#39;neo4j&#39; is unavailable. Cannot reset neo4j database",
          "uuid": 63477398,
          "view_count": 1291
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:325"
      },
      {
        "identity": 5449,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I would like to share my thoughts with you and try to get some advice. I would like to define my application with the best architecture as possible. Any comment would be highly appreciated. Here we go...

**My technologies:** NestJs(Node), neo4j/arangodb(graph DB), Nginx for proxy(Micro-services Approach).

**My business case:** SaaS application. Many customers with many users, one database per customer and the same code (just one instance) of our codebase.&lt;br&gt;
we have a set of data models which will be same for all customer but a relation between them will differ. As per my research GraphDB is the best match for such operations. so I&#39;m planning to create separate Instance/Database for each customer otherwise too many relations will make harder to scale.

**Problem:** From my point of view the problem can be seen with two different approach.

 1. I need to allow multiple users to connect to different databases at the same time with the same code (just one installation). In Nestjs App how can I change the database configuration on each API request. Shall I save DB URI in a table, based on user/customer type it will fetch DB URI? then other concerns like does it affect on latency time, if any request failed then is there any possibility that request can fetch data from wrong DB?
 2. How can we create sub-graphs in neo4j/arangodb so we can fetch sub-graph based on the customer.

On the other hand, I found a couple of interesting links:&lt;br&gt;
https://neo4j.com/developer/multi-tenancy-worked-example/ &lt;br&gt;
https://www.arangodb.com/enterprise-server/oneshard/ &lt;br&gt;
https://dzone.com/articles/multitenant-graph-applications

Someone could provide me aditional info?

Thanks for your time

Best regards
 
",
          "link": "https://stackoverflow.com/q/66241383",
          "creation_date": 1613562577,
          "answer_count": 1,
          "title": "Multi-tenancy Architecture in a graph DB",
          "uuid": 66241383,
          "view_count": 206
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5449"
      },
      {
        "identity": 5293,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have a neo4j desktop (1.4.3) database on my Windows PC. in an html code, I am connectecting to the DB using  

`const driver = neo4j.driver(&quot;bolt://IP_ADDRESS:7687&quot;, neo4j.auth.basic(&quot;neo4j&quot;, &quot;PASSWORD&quot;));`

After that I query the DB and display the results on the web page (I use leafletjs maps, but this is not the issue)

     var session = driver.session();
       session
      .run(`MATCH....etc.... return ....
        `)
      .subscribe({
         ...... etc

Everything is fine so far. I run the page on my PC or from another PC in my home network, everything is fine. The setting of neo4j is (dbms.default_listen_address=0.0.0.0) no issues there.

The question is how do I expose this page to the colleagues outside my network?
Using noip.com, I got a temporary domain mapped to my external IP.
I also configured the router to forward port 80.  
But when the page Javascript gets loaded on an external client, it tries to connect to neo4j on that client. When I put the external IP addtess in &quot;const driver ...&quot; the connection does not work. 

How do I make the connection to the DB from my server, but the queries to the DB come from the client who loaded the Javascript?

Edit: Forgot to mention that I am also using Apache Web Server (Xampp) to serve the page to remote users.

",
          "link": "https://stackoverflow.com/q/66738003",
          "creation_date": 1616363931,
          "title": "neo4j server side javascript",
          "answer_count": 1,
          "uuid": 66738003,
          "view_count": 34
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5293"
      },
      {
        "identity": 4804,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 68630257,
          "body_markdown": "I&#39;m using Neptune version 1.0.5.0 with the bolt+s protocol.  
I&#39;ve run the following query: MATCH (n) return n limit 1  
with Node.js neo4j latest driver (4.3) and getting the following error:  

    Neo4jError: &quot;Unexpected server exception &#39;Data type unsupported in Bolt in current release  
    http://www.w3.org/2001/XMLSchema#dateTime&#39;&quot;  
    :  
    at captureStacktrace (result.js:239:17)  
    at new Result (result.js:59:23)  
    at Session._run (session.js:165:16)  
    at Session.run (session.js:131:21)  

code:  

    const session = db.getSession();
    try {
        const result = await session.run(query);
        ...

While the same code works with a local Neo4j server.  
In addition, running: &quot;MATCH (n) return n.myprop limit 1&quot; works with Neptune.  
Any help will be appreciated.",
          "link": "https://stackoverflow.com/q/68630110",
          "creation_date": 1627962270,
          "answer_count": 1,
          "title": "Query Neptune nodes with Cypher not working in Node.js",
          "uuid": 68630110,
          "view_count": 31
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:4804"
      },
      {
        "identity": 5340,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 66586879,
          "body_markdown": "Currently, I have some code that query from `Neo4j` database then write to a CSV file on server:
```javascript
const session = driver.session();
const query = &#39;&lt;my query&gt;&#39;;
var file = fs.createWriteStream(&#39;export.csv&#39;);
file.write(&#39;&lt;some CSV header here&#39;);
await new Promise((resolve, reject) =&gt; {
  session.run(query).subscribe({
    onNext: i =&gt; {
      file.write(&#39;&lt;data of record i&gt;&#39;);
    },
    onCompleted: () =&gt; {
      session.close()
      file.end()
      resolve()
    },
    onError: error =&gt; {
      console.log(error)
      reject()
    }
  })
})
return response.download(&#39;export.csv&#39;);
```
Everything is fine until now I have more data in the database so the process to write a CSV file takes a long time, then the client receives a timeout error.

I have found a couple of solutions that use `pipe()` to send stream directly to the client but I tried it and failed because the result of `session.run()` is an observable not stream. Is there any other way?

Note: I&#39;m using AdonisJs for backend",
          "link": "https://stackoverflow.com/q/66586738",
          "creation_date": 1615480802,
          "answer_count": 1,
          "title": "How to send CSV data from Neo4j query results through Node.js/AdonisJs",
          "uuid": 66586738,
          "view_count": 72
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5340"
      }
    ]
  },
  {
    "t1": {
      "identity": 1682,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "cypher",
        "link": "https://stackoverflow.com/questions/tagged/cypher"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1682"
    },
    "t2": {
      "identity": 1685,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "database",
        "link": "https://stackoverflow.com/questions/tagged/database"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1685"
    },
    "questions": [
      {
        "identity": 5600,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I installed neo4j for the first time in my laptop and I got this error while creating the database. Error: Could not change password
and when I try recreating it I get  DBMS with name &quot;Graph DBMS 01341b61&quot; already exists 
so I checked the dbms folder, the databases are created but for some reason I get this error and they are not displayed on the neo4j desktop.",
          "link": "https://stackoverflow.com/q/65724553",
          "creation_date": 1610647672,
          "title": "neo4j Could not change password",
          "answer_count": 0,
          "uuid": 65724553,
          "view_count": 37
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5600"
      },
      {
        "identity": 585,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I&#39;m kinda new on neo4j 
I created a local database and wanted my teammates to connect to it remotely
so we downloaded Hamamchi VPN and connected to local network and all of them now can connect to the database using blot://localhost:port ,however the problem is that they can&#39;t connect to the server when my pc is sleeping since it&#39;s created on my PC.

is there another way to let them connect to my database even when my pc is on sleep mode?",
          "link": "https://stackoverflow.com/q/61565247",
          "creation_date": 1588448284,
          "answer_count": 1,
          "title": "Neo4j server connect while PC off?",
          "uuid": 61565247,
          "view_count": 23
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:585"
      },
      {
        "identity": 5304,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I have a list of garages and the cars that they provide:

   
        Store1: [Mazda, Ford, Porsche, VW, Nissan, Opel, Toyota, Seat, Volvo]
        Store2: [Porsche, Honda, Toyota, Audi]
        Store3: [Opel, Toyota, Volvo, Porsche, Kia, Mazda, Seat]
        Store4: [VW, Honda, Bentley, Alfa, Chevrolet, Subaru, Tesla]
        Store5: [Suzuki, VW, Nissan, Ferrari, Maserati, Jag]
        Store6: [Jag, Kia, Seat, Bentley, Alfa, Chevrolet, Ferrari, Mini]

I have to find the store which has the most similar options compared to Store 1. How would you structure a cypher to find similarities between nodes? 

",
          "link": "https://stackoverflow.com/q/66691009",
          "creation_date": 1616070128,
          "answer_count": 1,
          "title": "How to find Node with the most similarities Neo4j",
          "uuid": 66691009,
          "view_count": 29
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5304"
      },
      {
        "identity": 281,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am loading a CSV in `neo4j` but a header value named &#39;intent&#39; is not able to load as properties in below case.

    LOAD CSV WITH HEADERS FROM &quot;filePath&quot; AS row
    CREATE (cmd:Command {name: row.command, description: row.description,}), (act:Activity {name: row.intent})

because &#39;`IN`&#39; is a keyword in Cypher I guess which is why row. The intent is not get executed properly, please help me with the issue.
Any suggestions.",
          "link": "https://stackoverflow.com/q/63827953",
          "creation_date": 1599734462,
          "answer_count": 1,
          "title": "How to load csv with header value that contains a cypher keyword in Neo4j",
          "uuid": 63827953,
          "view_count": 40
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:281"
      },
      {
        "identity": 289,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 63798769,
          "body_markdown": "Due to unwanted scrip execution my database has some duplicate nodes and it looks like this

[![Bad Graph][1]][1]

From the image, there are multiple nodes with &#39;see&#39; and &#39;execute&#39; from p1 to m1.
I tried to eliminate them using this:

   

    MATCH (ur:Role)-[c:CAN]-&gt;(e:Entitlement{action:&#39;see&#39;})-[o:ON]-&gt;(s:Role {id:&#39;msci&#39;}) 
    WITH collect(e) AS rels WHERE size(rels) &gt; 1 
    FOREACH (n IN TAIL(rels) | DETACH DELETE n)

Resulting in this:

[![Worse Graph][2]][2]

As you can see here, it deletes all the nodes with &#39;see&#39; action.
I think I am missing something in the query which I am not sure of.
The good graph should be like this:

[![Good graph][3]][3]

EDIT: Added one more scenario with extra relations
[![Bad graph2][4]][4]


  [1]: https://i.stack.imgur.com/nHnpc.png
  [2]: https://i.stack.imgur.com/tMpKc.png
  [3]: https://i.stack.imgur.com/TVsZ0.png
  [4]: https://i.stack.imgur.com/yN1rc.png",
          "link": "https://stackoverflow.com/q/63780655",
          "creation_date": 1599493308,
          "answer_count": 2,
          "title": "Delete duplicate nodes between two nodes in Neo4j",
          "uuid": 63780655,
          "view_count": 71
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:289"
      }
    ]
  },
  {
    "t1": {
      "identity": 1682,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "cypher",
        "link": "https://stackoverflow.com/questions/tagged/cypher"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1682"
    },
    "t2": {
      "identity": 1695,
      "labels": [
        "Tag"
      ],
      "properties": {
        "name": "java",
        "link": "https://stackoverflow.com/questions/tagged/java"
      },
      "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:1695"
    },
    "questions": [
      {
        "identity": 5264,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am trying to get all graph data including nodes and relationships from neo4j using java into a Hashmap to be able to read all nodes and their data for further manipulation with the data. I have tried using this query but it returns an error. 
```
try (Session session = driver.session()) { 
	return session.run(&quot;MATCH (m) RETURN m&quot;);
}
```
I am trying to figure out how can I get the data in the right format.",
          "link": "https://stackoverflow.com/q/66851899",
          "creation_date": 1617010780,
          "answer_count": 1,
          "title": "get all graph data including nodes and relationships from neo4j using java into a hashmap",
          "uuid": 66851899,
          "view_count": 34
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5264"
      },
      {
        "identity": 381,
        "labels": [
          "Question"
        ],
        "properties": {
          "accepted_answer_id": 63352580,
          "body_markdown": "I&#39;m developing [a neo4j procedure in java][1]. I can test it with the custom data below.

```
@Test
public void commonTargetTest2() {
    // This is in a try-block, to make sure we close the driver after the test
    try (Driver driver = GraphDatabase.driver(embeddedDatabaseServer.boltURI(), driverConfig);
            Session session = driver.session()) {
        // And given I have a node in the database
        session.run(
                &quot;CREATE (n1:Person {name:&#39;n1&#39;}) CREATE (n2:Person {name:&#39;n2&#39;}) CREATE (n3:Person {name:&#39;n3&#39;}) CREATE (n4:Person {name:&#39;n4&#39;}) CREATE (n5:Person {name:&#39;n5&#39;})&quot;
                        + &quot;CREATE (n6:Person {name:&#39;n6&#39;}) CREATE (n7:Person {name:&#39;n7&#39;}) CREATE (n8:Person {name:&#39;n8&#39;}) CREATE (n9:Person {name:&#39;n9&#39;}) CREATE (n10:Person {name:&#39;n10&#39;})&quot;
                        + &quot;CREATE (n11:Person {name:&#39;n11&#39;}) CREATE (n12:Person {name:&#39;n12&#39;}) CREATE (n13:Person {name:&#39;n13&#39;})&quot;
                        + &quot;CREATE (n14:Person {name:&#39;n14&#39;}) CREATE &quot;
                        + &quot;(n1)-[:KNOWS]-&gt;(n6),(n2)-[:KNOWS]-&gt;(n7),(n3)-[:KNOWS]-&gt;(n8),(n4)-[:KNOWS]-&gt;(n9),(n5)-[:KNOWS]-&gt;(n10),&quot;
                        + &quot;(n7)-[:KNOWS]-&gt;(n11),(n8)-[:KNOWS]-&gt;(n12),(n9)-[:KNOWS]-&gt;(n13),&quot;
                        + &quot;(n11)-[:KNOWS]-&gt;(n14),(n12)-[:KNOWS]-&gt;(n14),(n13)-[:KNOWS]-&gt;(n14);&quot;);

        // name of the procedure I defined is &quot;p1&quot;, below I&#39;m calling it in cypher
        StatementResult result = session
                .run(&quot;CALL p1([1,3], [], 3, 0) YIELD nodes, edges return nodes, edges&quot;);

        InternalNode n = (InternalNode) result.single().get(&quot;nodes&quot;).asList().get(0);
        assertThat(n.id()).isEqualTo(13);
    }
}
```

This works fine but the data is newly generated with `CREATE` statements and it is very small. I want to test my procedure with an existing neo4j database server. So that I can see the performance/results of my procedure with real/big data.

I can also achieve that with the below code. I can connect to an up and running neo4j database.
```
@Test
public void commonTargetTestOnImdb() {
    // This is in a try-block, to make sure we close the driver after the test
    try (Driver drv = GraphDatabase.driver(&quot;bolt://localhost:7687&quot;, AuthTokens.basic(&quot;neo4j&quot;, &quot;123&quot;));
            Session session = drv.session()) {

        // find 1 common downstream of 3 nodes
        StatementResult result = session.run(
                &quot;CALL commonStream([1047255, 1049683, 1043696], [], 3, 2) YIELD nodes, edges return nodes, edges&quot;);

        InternalNode n = (InternalNode) result.single().get(&quot;nodes&quot;).asList().get(0);
        assertThat(n.id()).isEqualTo(5);
    }

}
```

**NOW**, my problem is that I can&#39;t debug the codes of my procedure if I connect to an existing database. I package a JAR file and put it inside `plugin` folder of my neo4j database so that neo4j can call my procedure. I think I should debug the JAR file. I&#39;m using vscode and java extensions to debug and run tests. How can I debug JAR file with vscode?
 
  [1]: https://neo4j.com/docs/java-reference/current/extending-neo4j/procedures-and-functions/introduction/",
          "link": "https://stackoverflow.com/q/62952768",
          "creation_date": 1594984244,
          "answer_count": 1,
          "title": "attach debugger to neo4j procedure jar",
          "uuid": 62952768,
          "view_count": 122
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:381"
      },
      {
        "identity": 50,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I am trying to convert the following string into a Public Key using X509 and KeyFactory. The Code that I have written so far is:

    public static void main(String args[]) throws Exception {
		String key = &quot;MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAidRWp1iB0s2LKnAyAxUKCMmsKK9bMTdRUItZVRcV4lB0RXGla0wRTNeR6r5oqNo6poHUJ+QGPjAHDCztMjAZdtuMSQ+Lohn+TjDMIEi2sUNeXhZuXchwEE+3QTgPpIOGhjJtv4wmTjXD5UaZbYWuydNpgvFEDsF4jf02xM8t8a7nOgQIriPi83fa4XHXcoCcG&quot;
				+ &quot;EHDbpbtYUhVq12rJEBXUoVM1zi9LcDhEsgilpzRPlkT6zC+89SkgYHWTRtO2shLpJcnThkR1nyLqHU2Zgn1hSrNsy+T97bNL1Umhcs7e94WJ7WWO6PoSst4cknPIZhhRbeBHoJ9rdV+XLBoew7buDQSht2Jn&quot;
				+ &quot;zAm6A6Pvi+XhLVRlIEMLOsG6Y92Lwhuc21oSKeqklv9yDfMznJm0aeCbm3TWZehAfPD9EKJ4LgvSVbT&quot;
				+ &quot;tXSiOVvPS8JtzIedISqioSvPPP5v4qqdbqobGBv2uE0sdwYhXh+dTIFSO4WG+dQHMZpdZu38lFBec3y&quot;
				+ &quot;EuZJuKpvtX5AvdYgCEwMioZxE3ph4X3SJEbcqfR1KuuGnYwg6nmSEwotDVg55pEtSsgu3j2KRgM8GA&quot;
				+ &quot;7lkageikM4D6mq6vQ5fkedfzz8PuvQNe8BH3h2UZYmRjNvfKd8wt2bRKKFK7K4jCYT5riYo+5aEWS&quot;
				+ &quot;SrWvL+ECAwEAAQ==&quot;;
		getKey(key);
		  }
	public static PublicKey getKey(String key){
	    try{
	    	byte[] byteKey = Base64.getDecoder().decode(key.getBytes());	
	    	X509EncodedKeySpec X509publicKey = new X509EncodedKeySpec(byteKey);
	        KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;);

	        return kf.generatePublic(X509publicKey);
	    }
	    catch(Exception e){
	        e.printStackTrace();
	    }

	    return null;
	}

The error that I received, is the following: 

    java.lang.IllegalArgumentException: Input byte array has wrong 4-byte ending unit
	at java.base/java.util.Base64$Decoder.decode0(Base64.java:781)
	at java.base/java.util.Base64$Decoder.decode(Base64.java:567)
	at WannaCry.getKey(WannaCry.java:46)
	at WannaCry.main(WannaCry.java:27)

I&#39;m not sure if I&#39;m getting the wrong key, as this is from my assignment. This is the key I have to use for the Key.

    MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAidRWp1iB0s2LKnAyAxUKCMmsKK9bMTdRUItZ
    VRcV4lB0RXGla0wRTNeR6r5oqNo6poHUJ+QGPjAHDCzt/MjAZdtuMSQ+Lohn+TjDMIEi2sUNeXhZuXch
    w/EE+3QTgPpIOGhjJtv4wmTjXD5UaZbYWuydNpgvFEDsF4jf02xM8t8a7nOgQIriPi83f/a4XHXcoCcG
    EHDbpbtYUhVq12rJEBXUoVM1zi9LcDhEsgil/pzRPlkT6zC+89SkgYHWTRtO2shLpJcnThkR1nyLqHU2
    Zgn1hSrNsy+T97bNL1Umhcs7/e94WJ7WWO6PoSs/t4cknPIZhhRbeBHoJ9rdV+XLBoew7buDQSht2Jn/
    zAm6A6Pvi+XhLVRlIEMLOsG6Y92Lwhuc21oS/Keqklv9yDfMznJm0aeCbm3TWZehAfPD9EKJ4LgvSVbT
    tXSiOVvPS8JtzIedISqioSvPPP5v4qqdbqobGBv2uE0sdwYhXh+dTIFSO4WG+dQHMZpdZu38l/FBec3y
    EuZJuK/pvtX5AvdYgCEwMioZxE3ph4X3S/JEbcqfR1KuuGnYwg6nmSEwotDVg55pEtSsgu3j2KRgM8GA
    7lkageikM4D6m/q6vQ5fkedfzz8PuvQn/Ne8BH3h2UZYmRjNvfKd8wt2bRKKFK7K4jCYT5riYo+5aEWS
    SrWvL+ECAwEAAQ==
I have of course removed all of the line breakers (&quot;/&quot;) but I am getting this error, or sometimes I am getting

&gt; Invalid Byte Array Character D",
          "link": "https://stackoverflow.com/q/66138655",
          "creation_date": 1612966691,
          "answer_count": 0,
          "title": "Java Input byte array has wrong 4-byte ending unit",
          "uuid": 66138655,
          "view_count": 1851
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:50"
      },
      {
        "identity": 463,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I use the spring data neo4j @query to add a label to a node, but there are some syntaxes. How can I transfer param correctly?

Such as :

```java
@Query(&quot;MATCH (st) WHERE st.originId = $originId SET st:$label RETURN st&quot;)  
public Node addLabel(String originId, String label);

@Query(&quot;MATCH (st) WHERE st.originId = $originId SET st:label RETURN st&quot;) 
public Node addLabel(String originId, @Param(&quot;label&quot;) String label);

@Query(&quot;MATCH (st) WHERE st.originId = $originId SET st:$1 RETURN st&quot;)
public Node addLabel(String originId, String label);
```

All of the above statements have errors.The compiler told me there was an error in &#39;:&#39;.

So, What&#39;s the correct statements?",
          "link": "https://stackoverflow.com/q/62380890",
          "creation_date": 1592191775,
          "answer_count": 1,
          "title": "How to add a given label to given node by using spring data neo4j?",
          "uuid": 62380890,
          "view_count": 17
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:463"
      },
      {
        "identity": 5102,
        "labels": [
          "Question"
        ],
        "properties": {
          "body_markdown": "I would like to know which is the hashing algorithm used by Neo4j. In particular, Neo4j Enterprise 4.1.6.

When creating a new user, for example with the command `CREATE USER jack SET PASSWORD &#39;pass&#39;`, Neo4j will hash and store the password in the `system` database. But what hashing algorithm does it use?

I cannot find it in the official documentation so I looked it up on GitHub. [Here][1] is when the password is hashed and [this][2] is the class `SecureHasher` used for it. I also see SHA-256 in [this][3] class but there are two versions. Is it mentioned in the documentation or other documents?


  [1]: https://github.com/neo4j/neo4j/blob/e89ade8beeb5f491c218c67a0d2cfcb1c5a5c2b6/community/cypher/cypher/src/main/java/org/neo4j/cypher/internal/security/SystemGraphCredential.java#L90
  [2]: https://github.com/neo4j/neo4j/blob/e89ade8beeb5f491c218c67a0d2cfcb1c5a5c2b6/community/cypher/cypher/src/main/java/org/neo4j/cypher/internal/security/SecureHasher.java
  [3]: https://github.com/neo4j/neo4j/blob/e89ade8beeb5f491c218c67a0d2cfcb1c5a5c2b6/community/cypher/cypher/src/main/java/org/neo4j/cypher/internal/security/SecureHasherConfigurations.java#L31",
          "link": "https://stackoverflow.com/q/67480332",
          "creation_date": 1620705091,
          "answer_count": 0,
          "title": "Which hashing algorithm is used by Neo4J?",
          "uuid": 67480332,
          "view_count": 51
        },
        "elementId": "4:3afd030f-3dd3-47e4-9159-6695ff123cff:5102"
      }
    ]
  }
]